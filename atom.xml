<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lulu-cloud</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lulu-cloud.github.io/"/>
  <updated>2024-04-13T09:21:19.827Z</updated>
  <id>https://lulu-cloud.github.io/</id>
  
  <author>
    <name>lulu-cloud</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法学习：回溯法1-排列组合问题</title>
    <link href="https://lulu-cloud.github.io/2024/03/13/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%88%E4%B8%80%20%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/03/13/力扣刷题-回溯法（一 排列组合）/</id>
    <published>2024-03-13T01:46:20.000Z</published>
    <updated>2024-04-13T09:21:19.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>回溯法：n叉不等高度数的完全遍历，明确树的下一个分支宽度与树的高度。</p><p>对于宽度：<strong>这个体现在回溯法模板的for循环里面</strong></p><p>对于高度：<strong>体现在回溯法遍历结束的终止条件里面</strong></p><p><strong>这两个的核心思想如下:</strong></p><ol><li><strong>排列问题要搞一个visited数组标记已经访问的</strong></li><li><strong>组合问题要维护好一个起始的索引</strong></li></ol></blockquote><h1 id="1-排列问题-全排列"><a href="#1-排列问题-全排列" class="headerlink" title="1 排列问题 - 全排列"></a>1 排列问题 - 全排列</h1><blockquote><p>LeetCode 46</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：[[1]]</code></pre></blockquote><h2 id="1-1-树的确定"><a href="#1-1-树的确定" class="headerlink" title="1.1 树的确定"></a>1.1 树的确定</h2><ul><li>宽度：每一层都要遍历一下数组的每一个数字，那么树的宽度是nums.length，<strong>这个体现在回溯法模板的for循环里面</strong></li><li>高度：当前的临时list长度为数组长度，结束</li></ul><h2 id="1-2-排列：维护一个visited数组"><a href="#1-2-排列：维护一个visited数组" class="headerlink" title="1.2 排列：维护一个visited数组"></a>1.2 排列：维护一个visited数组</h2><p>回溯时也得同步这个<code>visited</code>数组</p><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;ans,List&lt;Integer&gt;temp,int[]visited,int[]nums)&#123;        if(temp.size()==nums.length)&#123;            ans.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        //回溯法        for(int i = 0;i&lt;nums.length;i++)&#123;            //没有遍历过            if(visited[i]==0)&#123;                temp.add(nums[i]);                visited[i] = 1;                //遍历树的下一层就好                backTrack(ans,temp,visited,nums);                //回溯                temp.remove(temp.size()-1);                visited[i] = 0;            &#125;        &#125;        return ;    &#125;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,new int[nums.length],nums);        return res;    &#125;&#125;</code></pre><h1 id="2-组合问题-组合"><a href="#2-组合问题-组合" class="headerlink" title="2 组合问题-组合"></a>2 组合问题-组合</h1><blockquote><p>LeetCode 77</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1输出：[[1]]</code></pre></blockquote><h2 id="2-1-树的确定"><a href="#2-1-树的确定" class="headerlink" title="2.1 树的确定"></a>2.1 树的确定</h2><ul><li><p>索引维护：维护一个<code>index</code>索引，保证当前遍历的起点</p></li><li><p>宽度：当前每次遍历<code>index-n</code>的<code>n-index+1</code>个数</p></li><li>高度：当前临时list长度为k，退出</li></ul><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int n,int k,int index)&#123;        if(temp.size()==k)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        //维护一个index，一直往后走        for(int i = index;i&lt;=n;i++)&#123;            temp.add(i);            backTrack(res,temp,n,k,i+1);            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,n,k,1);        return res;    &#125;&#125;</code></pre><h1 id="3-组合总数I"><a href="#3-组合总数I" class="headerlink" title="3 组合总数I"></a>3 组合总数I</h1><blockquote><p>LeetCode39</p></blockquote><h2 id="3-1-树的确定"><a href="#3-1-树的确定" class="headerlink" title="3.1 树的确定"></a>3.1 树的确定</h2><ul><li>高度：不定，如果当前<code>target&lt;0</code>直接返回，<code>target==0</code>，正确返回</li><li>宽度：<code>candidates</code>数组长度</li></ul><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int[]candidates,int target,int index)&#123;        //这一步必须，防止为空        if(target&lt;0)&#123;            return ;        &#125;        if(target==0)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        for(int i = index;i&lt;candidates.length;i++)&#123;            target -= candidates[i];            temp.add(candidates[i]);            //可重复的精髓，下一个的起始还是当前            backTrack(res,temp,candidates,target,i);            target += candidates[i];            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,candidates,target,0);        return res;    &#125;&#125;</code></pre><h1 id="4-组合总数"><a href="#4-组合总数" class="headerlink" title="4 组合总数"></a>4 组合总数</h1><blockquote><p>LeetCode 40</p><p>去重，需要排序后剪枝</p></blockquote><h2 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4.1 代码"></a>4.1 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int[]candidates,int target,int index)&#123;        //这一步必须，防止为空        if(target&lt;0)&#123;            return ;        &#125;        if(target==0)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        for(int i = index;i&lt;candidates.length;i++)&#123;            //大剪枝            if(target-candidates[i]&lt;0)&#123;                break;            &#125;            if(i&gt;index&amp;&amp;candidates[i]==candidates[i-1])&#123;                //小剪枝，与前一个元素相等                continue;            &#125;            target -= candidates[i];            temp.add(candidates[i]);            backTrack(res,temp,candidates,target,i+1);            target += candidates[i];            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        Arrays.sort(candidates);        backTrack(res,temp,candidates,target,0);        return res;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;回溯法：n叉不等高度数的完全遍历，明确树的下一个分支宽度与树的高度。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：排序</title>
    <link href="https://lulu-cloud.github.io/2024/03/06/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E6%8E%92%E5%BA%8F/"/>
    <id>https://lulu-cloud.github.io/2024/03/06/力扣刷题-排序/</id>
    <published>2024-03-06T01:57:12.000Z</published>
    <updated>2024-04-13T09:21:26.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1 堆排序"></a>1 堆排序</h1><h2 id="1-1-算法流程"><a href="#1-1-算法流程" class="headerlink" title="1.1 算法流程"></a>1.1 算法流程</h2><ol><li><p>从n/2-1处开始构建大根堆（使用堆调整算法）</p></li><li><p>堆顶元素此时为最大值，放入数组末尾，然后重新调整堆</p><blockquote><p>调整堆算法：</p><p>输入：数组arr、堆长度n、根节点位置root</p><ol><li>初始化左右子树与最大值索引变量，左子树为根节点位置*2，右子树为根节点位置*2+1，最大值索引为根节点索引</li><li>最大值索引变量取左右子树的最大值</li><li>如果此时最大值索引已经不是根节点索引<ul><li>交换根节点的值与最大索引值</li><li>递归调整子树</li></ul></li></ol></blockquote></li></ol><h2 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h2><pre><code class="lang-java">public class HeapSort &#123;    // 主要的堆排序方法    public static void heapSort(int arr[]) &#123;        int n = arr.length;        // 构建最大堆（初始时将数组看作一个完全二叉树）        for (int i = n / 2 - 1; i &gt;= 0; i--) &#123;            heapify(arr, n, i);        &#125;        // 一个一个从堆顶取出元素，将最大值放到数组末尾，然后重新调整堆        for (int i = n - 1; i &gt; 0; i--) &#123;            // 交换堆顶（最大值）和当前未排序部分的最后一个元素            int temp = arr[0];            arr[0] = arr[i];            arr[i] = temp;            // 调整堆，排除刚刚交换的元素            heapify(arr, i, 0);        &#125;    &#125;    // 将子树以root为根的堆调整为最大堆    public static void heapify(int arr[], int n, int root) &#123;        int largest = root; // 初始化根节点为最大值        int leftChild = 2 * root + 1; // 左子节点        int rightChild = 2 * root + 2; // 右子节点        // 如果左子节点比根节点大        if (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[largest]) &#123;            largest = leftChild;        &#125;        // 如果右子节点比根节点或左子节点大        if (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[largest]) &#123;            largest = rightChild;        &#125;        // 如果最大值不是根节点        if (largest != root) &#123;            // 交换根节点和最大值            int temp = arr[root];            arr[root] = arr[largest];            arr[largest] = temp;            // 递归调整受影响的子树            heapify(arr, n, largest);        &#125;    &#125;&#125;</code></pre><h1 id="2-对哈希表的排序"><a href="#2-对哈希表的排序" class="headerlink" title="2 对哈希表的排序"></a>2 对哈希表的排序</h1><pre><code class="lang-java">List&lt;Map.Entry&lt;String, Integer&gt;&gt; sortedEntries = new ArrayList&lt;&gt;(map.entrySet());        Collections.sort(sortedEntries, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;            @Override            public int compare(Map.Entry&lt;String, Integer&gt; entry1,                               Map.Entry&lt;String, Integer&gt; entry2) &#123;                // 按照value降序排序                int valueCompare = entry2.getValue().compareTo(entry1.getValue());                if (valueCompare != 0) &#123;                    return valueCompare;                &#125; else &#123;                    // 如果value相同，按照key升序排序                    return entry1.getKey().compareTo(entry2.getKey());                &#125;            &#125;        &#125;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-堆排序&quot;&gt;&lt;a href=&quot;#1-堆排序&quot; class=&quot;headerlink&quot; title=&quot;1 堆排序&quot;&gt;&lt;/a&gt;1 堆排序&lt;/h1&gt;&lt;h2 id=&quot;1-1-算法流程&quot;&gt;&lt;a href=&quot;#1-1-算法流程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析</title>
    <link href="https://lulu-cloud.github.io/2024/03/04/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BBtorch%E5%AE%9E%E8%B7%B53%EF%BC%9ATrafficClassificationPandemonium%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB/"/>
    <id>https://lulu-cloud.github.io/2024/03/04/加密流量分类torch实践3：TrafficClassificationPandemonium项目分享/</id>
    <published>2024-03-04T09:27:14.000Z</published>
    <updated>2024-03-04T09:49:07.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析"><a href="#加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析" class="headerlink" title="加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析"></a>加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析</h1><h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1 项目简介"></a>1 项目简介</h2><p>&emsp;&emsp;该项目是<strong>流量预处理</strong>与<strong>分类验证</strong>的一个统一实现，力求使用清晰的项目结构与最少的代码实现预设功能，目前支持的模型只有<code>1dcnn</code>、<code>app-net</code>两种，后续会进行更新。代码已经开源至<a href="https://github.com/lulu-cloud/TrafficClassificationPandemonium">露露云的github</a>，如果能帮助你，就给鼠鼠点一个star吧！！！</p><h2 id="2-项目使用"><a href="#2-项目使用" class="headerlink" title="2 项目使用"></a>2 项目使用</h2><h3 id="2-1-流量预处理-pcap-gt-npy"><a href="#2-1-流量预处理-pcap-gt-npy" class="headerlink" title="2.1 流量预处理(pcap-&gt;npy)"></a>2.1 流量预处理(pcap-&gt;npy)</h3><blockquote><p>提取网络数据流量的负载、包长序列、统计（当前版本还未实现）的特征，转为<code>npy</code>格式进行持久化存储，基于<code>flowcontainer库</code></p></blockquote><ol><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>preprocess</code>的参数，以下是一个示例</p><pre><code class="lang-yaml">preprocess:  traffic_path: ../traffic_path/android # 原始pcap的路径  datasets: ../datasets/android # 预处理后npy文件的路径  packet_num: 4 # 负载特征参数：流的前4包的负载  byte_num: 256 # 负载特征参数：每个包的前256个字节  ip_length: 128 # 包长特征参数：提取流前128个包长序列  threshold: 4 # 阈值：流包长小于4时舍弃  train_size: 0.8 # 训练集所占比例</code></pre><p>其中对于前<code>packet_num</code>个包的前<code>byte_num</code>字节可以如图说明</p><p><img src="D:\Blog\github\hexo\source\_posts\assets\image-20240304172008854.png" alt="image-20240304172008854"></p><p>负载、包长均作了舍长补短的操作，以达到特定的格式。</p></li><li><p><strong>预处理脚本运行</strong>：</p><p>配置<code>yaml_path</code>即配置文件路径，然后运行代码<code>entry/1_preprocess_with_flowcontainer.py</code></p><pre><code class="lang-py">def main():    yaml_path = r&quot;../configuration/traffic_classification_configuration.yaml&quot;    cfg = setup_config(yaml_path) # 获取 config 文件    pay, seq, label = getPcapIPLength(        cfg.preprocess.traffic_path,        cfg.preprocess.threshold,        cfg.preprocess.ip_length,        cfg.preprocess.packet_num,        cfg.preprocess.byte_num)    split_data(pay,seq,label,cfg.preprocess.train_size,cfg.preprocess.datasets)if __name__==&quot;__main__&quot;:    main()</code></pre></li><li><p><strong>样本字典补齐</strong>：运行完后，得到一个字典输出，将该字典复制到配置文件的<code>test/label2index</code>下</p><pre><code class="lang-yaml">label2index: &#123;&#39;qq&#39;: 0, &#39;微信&#39;: 1, &#39;淘宝&#39;: 2&#125;</code></pre></li></ol><h3 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h3><ol><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>train/test</code>的参数，以下是一个示例</p><p>~~~yaml<br>train:<br>  train_pay: ../TrafficClassificationPandemonium/datasets/android/train/pay_load.npy</p><h1 id="train-seq-npy-data-test-test-ip-length-npy"><a href="#train-seq-npy-data-test-test-ip-length-npy" class="headerlink" title="train_seq: ../npy_data/test/test/ip_length.npy"></a>train_seq: ../npy_data/test/test/ip_length.npy</h1><p>  train_seq: ../TrafficClassificationPandemonium/datasets/android/train/ip_length.npy<br>  train_sta: None<br>  train_label: ../TrafficClassificationPandemonium/datasets/android/train/label.npy<br>  test_pay: ../TrafficClassificationPandemonium/datasets/android/train/pay_load.npy<br>  test_seq: ../TrafficClassificationPandemonium/datasets/android/train/ip_length.npy<br>  test_sta: None<br>  test_label: ../TrafficClassificationPandemonium/datasets/android/train/label.npy<br>  BATCH_SIZE: 128<br>  epochs: 50 # 训练的轮数<br>  lr: 0.001 # learning rate<br>  model_dir: ../TrafficClassificationPandemonium/checkpoint # 模型保存的文件夹</p><h1 id="model-name-cnn1d-pth-模型的名称"><a href="#model-name-cnn1d-pth-模型的名称" class="headerlink" title="model_name: cnn1d.pth # 模型的名称"></a>model_name: cnn1d.pth # 模型的名称</h1><p>  model_name: app-net.pth # 模型的名称</p></li></ol><p>   test:<br>     evaluate: False # 如果是 True, 则不进行训练, 只进行评测<br>     pretrained: False # 是否有训练好的模型# # # {‘Chat’: 0, ‘Email’: 1, ‘FT’: 2, ‘P2P’: 3, ‘Streaming’: 4, ‘VoIP’: 5, ‘VPN_Chat’: 6, ‘VPN_Email’: 7, ‘VPN_FT’: 8, ‘VPN_P2P’: 9, ‘VPN_Streaming’: 10, ‘VPN_VoIP’: 11}<br>     label2index: {‘qq’: 0, ‘微信’: 1, ‘淘宝’: 2}<br>     confusion_path: ../TrafficClassificationPandemonium/result/confusion/ConfusionMatrix-app-net.png<br>   ~~~</p><ol><li><p><strong>运行脚本：</strong>运行代码<code>entry/2_train_test_model.py</code></p><h3 id="2-3-模型测试"><a href="#2-3-模型测试" class="headerlink" title="2.3 模型测试"></a>2.3 模型测试</h3></li><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>test</code>的参数的<code>evaluate</code>与<code>pretrained</code>为<code>True</code></p></li><li><p><strong>运行脚本：</strong>运行代码<code>entry/2_train_test_model.py</code></p></li></ol><h3 id="2-4-结果展现"><a href="#2-4-结果展现" class="headerlink" title="2.4 结果展现"></a>2.4 结果展现</h3><ol><li><p>混淆矩阵的展现</p><p>默认在<code>result/confusion</code>下</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745649.png" alt="image-20240304174048201"></p></li><li><p><code>acc</code>、<code>loss</code>曲线的展现</p><p>训练中或者训练后，使用<code>tensorboard --logdir /result/tensorboard</code>进行查看</p></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041746995.png" alt="image-20240304174254396"></p><h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3 项目结构"></a>3 项目结构</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745638.png" alt="image-20240304173550142"></p><h2 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4 扩展性"></a>4 扩展性</h2><ul><li><p><strong>新增模型</strong>：按照<code>models</code>下面的示例进行新增，模型都有两个返回，一个是分类结果，一个是重构结果（框架为了兼容后续上传的模型）</p></li><li><p><strong>切换模型</strong>：在<code>entry/2_train_test_model.py</code>的20/21行进行导入切换即可,下图为一维卷积与appnet的切换示例</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745627.png" alt="image-20240304173853711"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析&quot;&gt;&lt;a href=&quot;#加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划3-股票收益系列</title>
    <link href="https://lulu-cloud.github.io/2024/03/03/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%20%E8%82%A1%E7%A5%A8%E6%94%B6%E7%9B%8A%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/03/03/力扣刷题-动态规划（三 股票收益）/</id>
    <published>2024-03-03T01:46:20.000Z</published>
    <updated>2024-04-13T09:20:46.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-买卖股票最佳时机"><a href="#1-买卖股票最佳时机" class="headerlink" title="1 买卖股票最佳时机"></a>1 买卖股票最佳时机</h1><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>一次买入卖出</strong></p></blockquote><h2 id="1-1-递归关系"><a href="#1-1-递归关系" class="headerlink" title="1.1 递归关系"></a>1.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日<strong>第一次</strong>入股的成本，<strong>之前没有买过</strong></p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出的股价，<strong>加上昨天手上有股票的收益</strong></li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p></li></ul><h2 id="1-2-边界条件"><a href="#1-2-边界条件" class="headerlink" title="1.2 边界条件"></a>1.2 边界条件</h2><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="2-买卖股票最佳时机II"><a href="#2-买卖股票最佳时机II" class="headerlink" title="2 买卖股票最佳时机II"></a>2 买卖股票最佳时机II</h1><p><strong>与第一题只改动了一行代码！</strong></p><blockquote><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>区别：能买入卖出股票很多次！</strong></p></blockquote><h2 id="2-1-递归关系"><a href="#2-1-递归关系" class="headerlink" title="2.1 递归关系"></a>2.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p><strong>今日入股的成本，加上昨天手上无股票的收益</strong></p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出的股价，<strong>加上昨天手上有股票的收益</strong></li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i]+dp[i-1][1])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p><h2 id="2-2-边界条件"><a href="#2-2-边界条件" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],-prices[i]+dp[i-1][1]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="3-买卖股票最佳时机III"><a href="#3-买卖股票最佳时机III" class="headerlink" title="3 买卖股票最佳时机III"></a>3 买卖股票最佳时机III</h1><blockquote><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>最多买入卖出两次！设置dp[len][4]数组，表示第一次第二次持有与未持有的最大收益</strong></p></blockquote><h2 id="3-1-递归关系"><a href="#3-1-递归关系" class="headerlink" title="3.1 递归关系"></a>3.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，</p><p>dp[i][0]代表第i天<strong>第一次买卖</strong>手上<strong>有股票</strong>的最大收益，可能是之前买的，也可能是今天第一次买的，</p><p>dp[i][1]代表第i天<strong>第一次买卖</strong>手上<strong>无股票</strong>的最大收益，可能本来就没有买，可能是卖了；</p><p>dp[i][2]代表第i天<strong>第二次买卖</strong>手上<strong>有股票</strong>的最大收益，可能是之前第二次买的，也可能是今天第二次买，</p><p>dp[i][1]代表第i天<strong>第二次买卖</strong>手上<strong>无股票</strong>的最大收益，可能早就卖了第二次，可能是今天卖了；</p><blockquote><p>那么，当前日<strong>第一次有股票</strong>的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p><strong>今日第一次入股</strong></p></li></ol><p>而当前日<strong>第一次无股票</strong>的最大收益：</p><ol><li><p>昨天也无股票的最大收益</p></li><li><p>今日卖出的股价，加上昨天手上有股票的收益</p></li></ol><p>当前日<strong>第二次有股票</strong>的最大收益的两天情况：</p><ol><li>昨天第二次有股票的收益（今天之前就已经买了第二次）</li><li>昨天第一次卖股票的收益-<strong>今天第二次入股的成本</strong>（今天买第二次）</li></ol><p>而当前日<strong>第二次无股票</strong>的最大收益：</p><ol><li>昨天第二次无股票的收益（今天之前就已经卖了第二次）</li><li>昨天第二次有股票的收益+今日股价（今日卖出第二次）</li></ol></blockquote><ul><li><p>当日第一次有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i])</script></li><li><p>当日第一次无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script></li><li><p>当日第二次有股票的时候</p><script type="math/tex; mode=display">dp[i][2] = max(dp[i-1][2],dp[i-1][1]-price[i])</script></li><li><p>当日第二次无股票的时候</p><script type="math/tex; mode=display">dp[i][3] = max(dp[i-1][3],dp[i-1][2]+price[i])</script></li></ul><h2 id="3-2-边界条件"><a href="#3-2-边界条件" class="headerlink" title="3.2 边界条件"></a>3.2 边界条件</h2><ul><li><p>第一日<strong>第一次</strong>有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日<strong>第一次</strong>无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li><li><p>第一日<strong>第二次</strong>有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日<strong>第二次</strong>无股票</p><script type="math/tex; mode=display">dp[0][0] = 0</script></li></ul><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][4];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        dp[0][2] = -prices[0];        dp[0][3] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            //第一次有股票            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);            //第一次无股票            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);            //第二次有股票            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]-prices[i]);            //第二次无股票            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]+prices[i]);        &#125;        return Math.max(Math.max(dp[len-1][0],dp[len-1][1]),Math.max(dp[len-1][2],dp[len-1][3]));    &#125;&#125;</code></pre><h1 id="4-买卖股票最佳时机IV"><a href="#4-买卖股票最佳时机IV" class="headerlink" title="4 买卖股票最佳时机IV"></a>4 买卖股票最佳时机IV</h1><blockquote><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>最多可以买卖k次！</strong></p></blockquote><h2 id="4-1-递归关系"><a href="#4-1-递归关系" class="headerlink" title="4.1 递归关系"></a>4.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp[len][2k]，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了；dp[i][2]代表第二次买卖手上有股票的最大收益，dp[i][3]代表第二次买卖手上无股票的最大收益；</p><p>……</p><p>递推得知</p><p>dp[i][(k-1)*2]代表第k次买卖手上有股票的最大收益</p><p>dp[i][(k-1)*2+1]代表第k次买卖手上无股票的最大收益</p><ul><li><p>当日有股票的时候</p><ul><li>前一日有股票的最大收益</li><li>前一日无股票的收益-当日入股市的成本<strong>（第一次入股只需成本）</strong><script type="math/tex; mode=display">dp[i][(k-1)*2] = max(dp[i-1][(k-1)*2],-price[i]+if(k-1==0)?0:dp[i-1][(k-1)*2-1])</script></li></ul></li><li><p>当日无股票的时候</p><ul><li>前一个无股票的最大收益</li><li>前一日有股票的最大收益+当日股市的股价</li></ul><script type="math/tex; mode=display">dp[i][(k-1)*2+1] = max(dp[i-1][(k-1)*2+1],dp[i-1][(k-1)*2]+price[i])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p><h2 id="2-2-边界条件-1"><a href="#2-2-边界条件-1" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li><li><p>第一日有股票(不管买入卖出折腾多少次)</p><script type="math/tex; mode=display">dp[0][(k-1)*2] = -price[0]</script></li><li><p>第一日无股票(不管买入卖出折腾多少次)</p><script type="math/tex; mode=display">dp[0][(k-1)*2+1] = 0</script></li></ul><h2 id="2-3-代码-1"><a href="#2-3-代码-1" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">public class Solution &#123;    public int maxProfit(int k, int[] prices) &#123;        int n = prices.length;        int[][] dp = new int[n][2 * k];        //初始化        for(int index=0;index&lt;2*k;index++)&#123;            if(index%2==0)&#123;                dp[0][index] = -prices[0];            &#125;else&#123;                dp[0][index] = 0;            &#125;        &#125;        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j &lt; k; j++) &#123;                dp[i][j * 2] = Math.max(dp[i - 1][j * 2], -prices[i] + (j != 0 ? dp[i - 1][j * 2 - 1] : 0));                dp[i][j * 2 + 1] = Math.max(dp[i - 1][j * 2 + 1], dp[i - 1][j * 2] + prices[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;2*k;i++)&#123;            ans = Math.max(ans,dp[n-1][i]);        &#125;        return ans;    &#125;&#125;</code></pre><h1 id="5-买卖股票含冷冻期"><a href="#5-买卖股票含冷冻期" class="headerlink" title="5 买卖股票含冷冻期"></a>5 买卖股票含冷冻期</h1><h2 id="5-1-递归关系"><a href="#5-1-递归关系" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>与第二题一样，无限制交易次数，但是交易一次后一天内不能再次交易</p></blockquote><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日入股的成本，加上<strong>前天</strong>手上无股票的收益</p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出，加上昨天手上有股票的收益</li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],dp[i-2][1]-price[i])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],dp[i-1][0]+price[i])</script></li><li><h2 id="2-2-边界条件-2"><a href="#2-2-边界条件-2" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li></ul><blockquote><p>初始化两天</p></blockquote><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li><li><p>第二日有股票</p><script type="math/tex; mode=display">dp[1][0] = max(dp[0][0],dp[0][1]-price[1])</script></li><li><p>第二日无股票</p><script type="math/tex; mode=display">dp[1][1] = max(dp[0][1],dp[0][0]+price[1])</script></li></ul><h2 id="2-3-代码-2"><a href="#2-3-代码-2" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        if(len&lt;2)&#123;            return 0;        &#125;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        dp[1][0] = Math.max(dp[0][0],dp[0][1]-prices[1]);        dp[1][1] = Math.max(dp[0][1],dp[0][0]+prices[1]);        //开始遍历        for(int i = 2;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],dp[i-2][1]-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="6-买卖股票含手续费"><a href="#6-买卖股票含手续费" class="headerlink" title="6 买卖股票含手续费"></a>6 买卖股票含手续费</h1><h2 id="5-1-递归关系-1"><a href="#5-1-递归关系-1" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>与第二题一样，无限制交易次数，交易一次后要扣钱fee</p></blockquote><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日入股的成本，加上<strong>昨天</strong>手上无股票的收益</p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出，加上昨天手上有股票的收益，并且减去<strong>手续费fee</strong></li></ol></blockquote><ul><li>当日有股票的时候</li></ul><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],dp[i-1][1]-price[i])</script><ul><li>当日无股票的时候<script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],dp[i-1][0]+price[i]-fee)</script></li></ul><h2 id="2-2-边界条件-3"><a href="#2-2-边界条件-3" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2><blockquote><p>初始化两天</p></blockquote><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="2-3-代码-3"><a href="#2-3-代码-3" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        if(len&lt;2)&#123;            return 0;        &#125;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-买卖股票最佳时机&quot;&gt;&lt;a href=&quot;#1-买卖股票最佳时机&quot; class=&quot;headerlink&quot; title=&quot;1 买卖股票最佳时机&quot;&gt;&lt;/a&gt;1 买卖股票最佳时机&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：二叉树</title>
    <link href="https://lulu-cloud.github.io/2024/02/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lulu-cloud.github.io/2024/02/26/力扣刷题-二叉树/</id>
    <published>2024-02-26T01:54:20.000Z</published>
    <updated>2024-04-13T09:21:05.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树的核心是三个dfs与bfs层序遍历</p></blockquote><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;二叉树的核心是三个dfs与bfs层序遍历&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划2-字符串与子序列问题</title>
    <link href="https://lulu-cloud.github.io/2024/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/02/25/力扣刷题-动态规划（二 字符串相关）/</id>
    <published>2024-02-25T01:46:20.000Z</published>
    <updated>2024-04-13T09:20:29.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般关于字符串的都是二维dp</p></blockquote><h1 id="1-最大回文子串"><a href="#1-最大回文子串" class="headerlink" title="1 最大回文子串"></a>1 最大回文子串</h1><h2 id="1-1-递归关系"><a href="#1-1-递归关系" class="headerlink" title="1.1 递归关系"></a>1.1 递归关系</h2><p>&emsp;&emsp;    设置dp[i][j]是以索引i开头索引j结尾的字符串是否为回文串</p><script type="math/tex; mode=display">dp[i][j] = dp[i+1][j-1]\&\&s[i]==s[j]</script><blockquote><p>此种遍历由下到上开始遍历</p></blockquote><h2 id="1-2-边界条件"><a href="#1-2-边界条件" class="headerlink" title="1.2 边界条件"></a>1.2 边界条件</h2><ol><li><p>串长度为1，都是回文串</p><script type="math/tex; mode=display">dp[i][i] = true</script></li><li><p>子串长度为2</p><script type="math/tex; mode=display">dp[i][i+1] = s[i]==s[i+1]</script></li></ol><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public String longestPalindrome(String s) &#123;        //与字符串的一般都是二维        /**        设置dp[i][j]是以索引i开头索引j结尾的字符串是否为回文串        dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i]==s[j]        初始 dp[i][i] = 1, dp[i][i+1] = s[i]==s[i+1]         */        int len = s.length();        boolean[][]dp = new boolean[len][len];        int start = 0;        int end = 0;        //初始化        for(int i = 0;i&lt;len;i++)&#123;            dp[i][i] = true;            start = i;            end = i+1;        &#125;        for(int i = 0;i&lt;len-1;i++)&#123;            dp[i][i+1] = s.charAt(i)==s.charAt(i+1);            if(dp[i][i+1])&#123;                start = i;                end = i+2;            &#125;        &#125;        //从下到上遍历        for(int i = len-3;i&gt;=0;i--)&#123;            for(int j = i+2;j&lt;len;j++)&#123;                dp[i][j] = dp[i+1][j-1]&amp;&amp;s.charAt(i)==s.charAt(j);                if(dp[i][j])&#123;                    if(j+1-i&gt;end-start)&#123;                        start = i;                        end = j+1;                    &#125;                &#125;            &#125;        &#125;        return s.substring(start,end);    &#125;&#125;</code></pre><h1 id="2-最长回文子序列"><a href="#2-最长回文子序列" class="headerlink" title="2 最长回文子序列"></a>2 最长回文子序列</h1><h2 id="2-1-递归关系"><a href="#2-1-递归关系" class="headerlink" title="2.1 递归关系"></a>2.1 递归关系</h2><script type="math/tex; mode=display">s[i]==s[j]?dp[i][j]=dp[i+1][j-1]+2:max(dp[i+1][j],dp[i][j-1])</script><h2 id="2-2-边界条件"><a href="#2-2-边界条件" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2><p>起始的</p><script type="math/tex; mode=display">dp[i][i]=1</script><h2 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int longestPalindromeSubseq(String s) &#123;        int n = s.length();        int[][]dp = new int[n][n];        for(int i =0;i&lt;n;i++)&#123;            dp[i][i] = 1;        &#125;        //倒着遍历        for(int i = n-2;i&gt;=0;i--)&#123;            for(int j = i+1;j&lt;n;j++)&#123;                if(s.charAt(i)==s.charAt(j))&#123;                    dp[i][j] = dp[i+1][j-1]+2;                &#125;else&#123;                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[0][n-1];    &#125;&#125;</code></pre><h1 id="3-单词拆分（一维dp）"><a href="#3-单词拆分（一维dp）" class="headerlink" title="3 单词拆分（一维dp）"></a>3 单词拆分（一维dp）</h1><h2 id="3-1-递归关系"><a href="#3-1-递归关系" class="headerlink" title="3.1 递归关系"></a>3.1 递归关系</h2><p>&emsp;&emsp;首先弄一个集合set，存储字符串列表中的所有字符串，然后开辟一维dp数组，其中<code>dp[i]</code>的意思代表s[0,i-1]的子串是否能被列表集合单词拆分。二维遍历dp数组</p><script type="math/tex; mode=display">dp[i] = dp[j]\&\&set.contans(s.substring(i,j))</script><p>只要遍历中有一次为<code>true</code>立马结束循环</p><h2 id="3-2-边界条件"><a href="#3-2-边界条件" class="headerlink" title="3.2 边界条件"></a>3.2 边界条件</h2><p>&emsp;&emsp;起始的<code>dp[0]</code>为true</p><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        boolean[]dp = new boolean[s.length()+1];        Set&lt;String&gt;set = new HashSet&lt;&gt;(wordDict);        dp[0] = true;        for(int i = 1;i&lt;s.length()+1;i++)&#123;            for(int j = 0;j&lt;i;j++)&#123;                dp[i] = dp[j]&amp;&amp;set.contains(s.substring(j,i));                if(dp[i]==true)&#123;                    break;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;&#125;</code></pre><h1 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4 编辑距离"></a>4 编辑距离</h1><h2 id="4-1-递归关系"><a href="#4-1-递归关系" class="headerlink" title="4.1 递归关系"></a>4.1 递归关系</h2><script type="math/tex; mode=display">dp[i][j] = s[i]==s[j]?:dp[i-1][j-1]:min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</script><h2 id="4-2-边界条件"><a href="#4-2-边界条件" class="headerlink" title="4.2 边界条件"></a>4.2 边界条件</h2><p>&emsp;&emsp;需要注意的是在申请dp数组的时候多申请一行一列，存放空串，空串到任意串的步数都是任意串的长度</p><h2 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int minDistance(String word1, String word2) &#123;        int m = word1.length();        int n = word2.length();        int[][]dp = new int[m+1][n+1];        //初始化边界        for(int i = 0;i&lt;m+1;i++)&#123;            dp[i][0] = i;        &#125;        for(int i = 0;i&lt;n+1;i++)&#123;            dp[0][i] = i;        &#125;        //递归        for(int i = 1;i&lt;m+1;i++)&#123;            for(int j = 1;j&lt;n+1;j++)&#123;                //注意这里的i-1，j-1                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;                    dp[i][j]=dp[i-1][j-1];                &#125;else&#123;                    dp[i][j] = Math.min(                        Math.min(dp[i-1][j],dp[i][j-1]),                        dp[i-1][j-1])                        +1;                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;</code></pre><h1 id="5-最长递增子序列"><a href="#5-最长递增子序列" class="headerlink" title="5 最长递增子序列"></a>5 最长递增子序列</h1><h2 id="5-1-递归关系"><a href="#5-1-递归关系" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>双重循环，dp[i]代表到以nums[i]结尾的最长子序列的长度，设定第二个变量j，j由0-&gt;i，每次如果nums[i]&gt;nums[j]，那么dp[i]刷新为max(dp[j]+1)，最后取dp的最大值</p></blockquote><script type="math/tex; mode=display">dp[i] = nums[i]>nums[j]?max(dp[j])+1:1</script><h2 id="5-2-边界条件"><a href="#5-2-边界条件" class="headerlink" title="5.2 边界条件"></a>5.2 边界条件</h2><blockquote><p>起始初始化所有的dp[i] = 1</p></blockquote><h2 id="5-3-代码"><a href="#5-3-代码" class="headerlink" title="5.3 代码"></a>5.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        int len = nums.length;        int[]dp = new int[len];        Arrays.fill(dp,1);        int ans = 1;        for(int i = 1;i&lt;len;i++)&#123;            for(int j = 0 ;j&lt;i;j++)&#123;                if(nums[i]&gt;nums[j])&#123;                    dp[i] = Math.max(dp[i],dp[j]+1);                    ans = Math.max(ans,dp[i]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="5-4-最长递增子序列的个数"><a href="#5-4-最长递增子序列的个数" class="headerlink" title="5.4 最长递增子序列的个数"></a>5.4 最长递增子序列的个数</h2><blockquote><ol><li>多使用一个cnt数组记录当前nums[i]结尾的最长地址子序列的个数</li><li>如果dp[j]+1&gt;dp[i]，代表当前的最长子序列更新了，那么cnt[i] = cnt[j]，为前一个</li><li>如果dp[j]+1==dp[i]，那么最长子序列的个数又得更新，cnt[i]+=cnt[j]</li><li>最后取dp[i]最大值对应的cnt数值即可</li></ol></blockquote><pre><code class="lang-JAVA">class Solution &#123;    public int findNumberOfLIS(int[] nums) &#123;        int len = nums.length;        int[]dp = new int[len];        int[]cnt = new int[len];        Arrays.fill(dp,1);        Arrays.fill(cnt,1);        int ans = 1;        for(int i = 1;i&lt;len;i++)&#123;            for(int j = 0 ;j&lt;i;j++)&#123;                if(nums[i]&gt;nums[j])&#123;                    if(dp[j]+1&gt;dp[i])&#123;                        //找到了更长的,那边数字不变                        cnt[i] = cnt[j];                    &#125;else if(dp[j]+1==dp[i])&#123;                        //又一样长的，加上                        cnt[i] += cnt[j];                    &#125;                    dp[i] = Math.max(dp[i],dp[j]+1);                &#125;            &#125;            ans = Math.max(ans,dp[i]);        &#125;        //然后找出cnt中为ans的统计        int res = 0;        for(int i = 0;i&lt;len;i++)&#123;            if(dp[i]==ans)&#123;                res += cnt[i];            &#125;        &#125;        return res;    &#125;       &#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一般关于字符串的都是二维dp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-最大回文子串&quot;&gt;&lt;a href=&quot;#1-最大回文子串&quot; class=&quot;headerlink&quot; title=&quot;1 最大回文子串&quot;&gt;&lt;/a&gt;1 最大回文子串&lt;/h1&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划1-打家劫舍</title>
    <link href="https://lulu-cloud.github.io/2024/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/02/22/力扣刷题-动态规划（一 打家劫舍）/</id>
    <published>2024-02-22T09:02:18.000Z</published>
    <updated>2024-04-13T09:20:59.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p>&emsp;&emsp;设置dp[i]为当前打劫到第i个户的最大收益，那么，当前收益等于<strong>前一个户的最大收益</strong>与<strong>前两个户的最大收益加上当前户的收益</strong>的最大值：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1],dp[i-2]+nums[i])</script><h1 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h1><ol><li>数组长度为0的情况</li><li>数组长度为1的情况</li><li>dp[0]为第一户的收益，dp[1]为前两个户收益的最大值</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-java">class Solution &#123;    public int rob(int[] nums) &#123;        if(nums==null||nums.length==0)&#123;            return 0;        &#125;        int len = nums.length;        if(len==1)&#123;            return nums[0];        &#125;        int[]dp = new int[len];        dp[0] = nums[0];        dp[1] = Math.max(dp[0],nums[1]);        for(int i = 2;i&lt;len;i++)&#123;            //当前的dp = max(前一个dp值,前两个dp值+当前值)            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);        &#125;        return dp[len-1];    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递推关系&quot;&gt;&lt;a href=&quot;#递推关系&quot; class=&quot;headerlink&quot; title=&quot;递推关系&quot;&gt;&lt;/a&gt;递推关系&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;设置dp[i]为当前打劫到第i个户的最大收益，那么，当前收益等于&lt;strong&gt;前一个户的最大收益&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征</title>
    <link href="https://lulu-cloud.github.io/2023/12/11/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-3%EF%BC%9A%E5%88%A9%E7%94%A8cic-flowmeter%E5%B7%A5%E5%85%B7%E6%8F%90%E5%8F%96%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/"/>
    <id>https://lulu-cloud.github.io/2023/12/11/流量预处理-3：利用cic-flowmeter工具提取流量特征/</id>
    <published>2023-12-11T02:48:14.000Z</published>
    <updated>2023-12-11T02:58:42.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征"><a href="#加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征" class="headerlink" title="加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征"></a>加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>&emsp;&emsp;许多研究工作基于<code>CIC-FlowMeter</code>工具提取的csv文件的基础上进行的,目前开源的<code>CIC-FlowMeter</code>工具要么使用jdk编译，要么是给出一个exe可执行文件然后使用图形化界面一个一个处理pcap，在处理大量pacp文件很麻烦，如下图。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048240.png" alt="离线处理pcap"></p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h2><p>这里基于给出的exe可执行文件，利用python脚本批量处理pcap转化为csv文件。</p><pre><code class="lang-python">import osdef generate_batch_csv(pcap_dir,csv_dir,cic_path):    &quot;&quot;&quot;批量将pcap转csv&quot;&quot;&quot;    for label in os.listdir(pcap_dir):        label_path = os.path.join(pcap_dir, label)        csv_label_dir = os.path.join(csv_dir,label)        if not os.path.exists(csv_label_dir):            os.makedirs(csv_label_dir)        for pcap in os.listdir(label_path):            pcap_file = os.path.join(label_path,pcap)            print(f&quot;Analyzing &#123;pcap_file&#125;...&quot;)            # 调用cfm.bat脚本对pcap文件进行分析            os.chdir(cic_path)            os.system(f&#39;call cfm.bat &quot;&#123;pcap_file&#125;&quot; &quot;&#123;csv_label_dir&#125;&quot;&#39;)            print(&quot;Done.&quot;)        print(&quot;完成了&#123;&#125;的处理&quot;.format(label))    print(&quot;所有的都处理完成&quot;)def main():    # 设置pcap和csv文件夹路径    pcap_dir = r&quot;xxx&quot;    csv_dir = r&quot;xx&quot;    cic_dir = r&quot;xx&quot;    generate_batch_csv(pcap_dir,csv_dir,cic_dir)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="3-参数解释与执行效果"><a href="#3-参数解释与执行效果" class="headerlink" title="3 参数解释与执行效果"></a>3 参数解释与执行效果</h2><h3 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h3><ul><li><p><code>pcap_dir</code>:是原始pcap所在的目录，底下是各个标签的目录与对应的pcap，具体如下</p><pre><code>---pcap_dir   -- label_0_dir:      --- label_0_pcap_0      --- label_0_pcap_1      --- label_0_pcap_2      ...   -- label_1_dir:      --- label_1_pcap_0      --- label_1_pcap_1      --- label_1_pcap_2      ...  ...  --- lable_n-1_dir:      --- label_n-1_pcap_0      --- label_n-1_pcap_1      --- label_n-1_pcap_2</code></pre></li><li><p><code>csv_dir</code>:是将csv文件存储的文件夹</p></li><li><p><code>cic_dir</code>:是cic工具的<code>bin</code>目录的所在路径</p><blockquote><p>我这里的示例</p><ul><li><p><code>pcap_dir</code>:</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111049512.png" alt="image-20231211104050740"></p></li><li><p><code>csv_dir</code>:</p><p>随意新建一个文件夹</p></li><li><p><code>cic_dir</code>:</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048581.png" alt="image-20231211104333732"></p></li></ul></blockquote></li></ul><h3 id="3-2-执行效果"><a href="#3-2-执行效果" class="headerlink" title="3.2 执行效果"></a>3.2 执行效果</h3><ol><li><p>截图</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048727.png" alt="image-20231211104723276"></p></li><li><p>成果</p></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048293.png" alt="image-20231211104541121"></p><p> 以<code>iscx-vpn-novpn2016</code>数据集为例，6分钟搞定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征&quot;&gt;&lt;a href=&quot;#加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践5: 利用CIC-FlowMe
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Tor网络构建(1)-obfs4网桥配置</title>
    <link href="https://lulu-cloud.github.io/2023/12/05/tor-%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/"/>
    <id>https://lulu-cloud.github.io/2023/12/05/tor-网桥配置/</id>
    <published>2023-12-05T07:45:14.000Z</published>
    <updated>2024-04-13T09:10:29.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><blockquote><p> 搭配tor的obfs4网桥，本地tor浏览器使用该网桥访问tor网络</p></blockquote><h1 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h1><ol><li>本地windows客户端需要下载tor浏览器</li><li>准备一台海外vps，能有公网ip进行访问</li></ol><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="1-网桥vps配置"><a href="#1-网桥vps配置" class="headerlink" title="1 网桥vps配置"></a>1 网桥vps配置</h2><h3 id="安装tor与obfs4"><a href="#安装tor与obfs4" class="headerlink" title="安装tor与obfs4"></a>安装tor与obfs4</h3><pre><code>apt-get install tor -yapt-get install obfs4proxy -y</code></pre><h3 id="安装nyx监控工具"><a href="#安装nyx监控工具" class="headerlink" title="安装nyx监控工具"></a>安装nyx监控工具</h3><pre><code>apt-get install nyx -y</code></pre><h3 id="修改tor配置文件"><a href="#修改tor配置文件" class="headerlink" title="修改tor配置文件"></a>修改tor配置文件</h3><ol><li>使用该命令修改配置文件</li></ol><pre><code>vi /etc/tor/torrc</code></pre><ol><li>按照官网给出的示例demo，修改</li></ol><pre><code>BridgeRelay 1ORPort port1ServerTransportPlugin obfs4 exec /usr/bin/obfs4proxyServerTransportListenAddr obfs4 0.0.0.0:port2ExtORPort autoPublishServerDescriptor 0Nickname yourName</code></pre><blockquote><p>port1与port2都是自定义的，同时修改vps的防火墙将该两个端口打开</p></blockquote><h3 id="重启tor，记录机器指纹与证书"><a href="#重启tor，记录机器指纹与证书" class="headerlink" title="重启tor，记录机器指纹与证书"></a>重启tor，记录机器指纹与证书</h3><p>使用命令重启tor，然后使用nyx工具进行监控</p><pre><code>systemctl restart tor</code></pre><pre><code>nyx</code></pre><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051527105.png" alt="image-20231205151255192"></p><blockquote><ol><li><p>获取指纹</p><pre><code>cat /var/lib/tor/fingerprint</code></pre><p>该字符串其实就是nyx界面的右上角的fingerprint</p><p><img src="D:\Blog\github\hexo\source\_posts\assets\image-20231206092956574.png" alt="image-20231206092956574"></p></li><li><p>获取证书</p><pre><code>cat /var/lib/tor/pt_state/obfs4_bridgeline.txt</code></pre><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528606.png" alt="image-20231205152826903"></p><p><code>Bridge obfs4 &lt;IP ADDRESS&gt;:&lt;PORT&gt; &lt;FINGERPRINT&gt; cert=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx iat-mode=0</code></p></li></ol></blockquote><h2 id="2-本地客户端配置"><a href="#2-本地客户端配置" class="headerlink" title="2 本地客户端配置"></a>2 本地客户端配置</h2><ol><li><p>手动选择网桥</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528646.png" alt="image-20231205152036696"></p></li><li><p>填入网桥</p><p>根据第一大部分得到的信息，按照如下格式填充网桥字符串</p><p><code>obfs4 你的vps ip地址:port2 指纹 cert=证书 iat-mode=0</code></p></li><li><p>开始上网</p><blockquote><p>在没有科学上网的环境下尝试访问youtube，点左上角的线路可以看到中继转发情况，通过配置的网桥，然后经历一个普通中继与出口中继转发到目的网络。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528923.png" alt="image-20231205152419619"></p></blockquote></li></ol><blockquote><p>在浏览器同步点击的时候，nyx查看到vps的流量是有突发的上下行流量的</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528493.png" alt="image-20231205152637974"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot; class=&quot;headerlink&quot; title=&quot;实验目标&quot;&gt;&lt;/a&gt;实验目标&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 搭配tor的obfs4网桥，本地tor浏览器使用该网桥访问tor网络&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Tor" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/Tor/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>学习算法：图算法-拓扑排序</title>
    <link href="https://lulu-cloud.github.io/2023/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%9B%BE-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://lulu-cloud.github.io/2023/04/12/力扣刷题-图-拓扑排序/</id>
    <published>2023-04-12T03:27:18.000Z</published>
    <updated>2024-04-13T09:21:56.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-算法流程"><a href="#一-算法流程" class="headerlink" title="一  算法流程"></a>一  算法流程</h1><ol><li><p>计算每一个节点入度</p><blockquote><p>一般是用数组计算即可</p></blockquote></li><li><p>使用邻接表数据结构，构建图</p><blockquote><p>java里面可以申明一个数组,数组元素类型为一个list,每一个数组是一个list的引用,存储该节点所有的邻接节点</p><pre><code class="lang-java">//邻接表,外层是一个数组，每一个数组引用一个list对象，存储该节点所有的邻接节点List&lt;Integer&gt;[]graph = new ArrayList[numCourses];</code></pre></blockquote></li><li><p>进行拓扑排序，采用<code>BFS</code>算法</p><ul><li><p>构建队列，将所有入度为0的节点进队</p></li><li><p>循环（队列非空）</p><ul><li>将上一轮入队的节点出队，并且将他们的邻接节点都入队</li></ul></li></ul></li><li><p>统计出入队的节点总数,如果小于图节点总数,拓扑排序失败,图中有环.否则成功</p></li></ol><h1 id="二-课程表-1-2"><a href="#二-课程表-1-2" class="headerlink" title="二 课程表(1,2)"></a>二 课程表(1,2)</h1><pre><code class="lang-java">class Solution &#123;    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;        // 1 使用数组存储每一个节点的入度        // 2 构建图，使用邻接表的方法        // 3 拓扑排序（广搜）        //  3.1 将入度为0的节点进队          //循环  3.2 如果队列不空          //   3.3 第一个节点出队，将它的邻居入队        // 4 统计出入队的节点数目，如果等于图节点数目，则拓扑排序成功，否则失败        //1 存储度数表        int[]degrees = new int[numCourses];        //2 邻接表,外层是一个数组，每一个数组引用一个list对象，存储该节点所有的邻接节点        List&lt;Integer&gt;[]graph = new ArrayList[numCourses];        for(int i = 0;i&lt;numCourses;i++)&#123;            graph[i] = new ArrayList&lt;&gt;();        &#125;        // 构建表与图        for(int []item:prerequisites)&#123;            int inNode = item[1];            int outNode = item[0];            degrees[outNode]++;            graph[inNode].add(outNode);        &#125;        Queue&lt;Integer&gt;queue = new LinkedList&lt;&gt;();        //3 入度为0的进队        for(int i =0;i&lt;numCourses;i++)&#123;            if(degrees[i]==0)&#123;                queue.add(i);            &#125;        &#125;        //计数        int cnt = 0;        while(!queue.isEmpty())&#123;            int size = queue.size();            for(int j =0 ;j&lt;size;j++)&#123;                cnt++;                int node = queue.poll();                for(int next:graph[node])&#123;                    //找到所有邻居节点                    //入度更新                    degrees[next]--;                    if(degrees[next]==0)&#123;                        //不会存在重复问题：                        //有向图，只会将入度为0的进入队列，只会进入一次                        queue.offer(next);                    &#125;                &#125;            &#125;        &#125;        return cnt==numCourses;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-算法流程&quot;&gt;&lt;a href=&quot;#一-算法流程&quot; class=&quot;headerlink&quot; title=&quot;一  算法流程&quot;&gt;&lt;/a&gt;一  算法流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;计算每一个节点入度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般是用数组计算即可&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：区间问题</title>
    <link href="https://lulu-cloud.github.io/2023/04/04/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://lulu-cloud.github.io/2023/04/04/力扣刷题-区间问题/</id>
    <published>2023-04-04T03:37:54.000Z</published>
    <updated>2024-04-13T09:21:41.177Z</updated>
    
    <content type="html"><![CDATA[<p>对力扣的区间类题目做一个总结！</p><h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><h2 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1 算法思想"></a>1 算法思想</h2><ol><li><p>按照区间起点升序排序</p><pre><code class="lang-java">//按照区间起始位置排序/**        如果v1[0]-v2[0]为正，代表v1与v2交换位置，故这是升序排序        */Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);</code></pre></li></ol><ol><li><p>设定<code>start</code>与<code>end</code>指针，首先初始化为第一个区间的两端值</p><pre><code class="lang-java">int start = intervals[0][0];int end = intervals[0][1];</code></pre></li></ol><ol><li><p>循环遍历，如果当前的<code>end</code>大于下一个区间的起点，那么说明两个区间有交集了，<code>end</code>更新，更新策略为当前<code>end</code>与下一个区间终点的最大值</p><pre><code class="lang-java">List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();for(int i = 1;i&lt;intervals.length;i++)&#123;    if(end&gt;=intervals[i][0])&#123;        end = Math.max(end,intervals[i][1]);    &#125;    else&#123;        ans.add(new int[]&#123;start,end&#125;);        start = intervals[i][0];        end = intervals[i][1];    &#125;&#125;</code></pre></li><li><p>最后一步由于<code>start</code>与<code>end</code>圈区间的未加入最后结果，再次更新一次</p><pre><code class="lang-java">//最后一个区间加一下ans.add(new int[]&#123;start,end&#125;);int[][]res = new int[ans.size()][2];return ans.toArray(res);</code></pre></li></ol><h2 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2 完整代码"></a>2 完整代码</h2><pre><code class="lang-java">class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        //0 特殊情况处理        if(intervals.length&lt;=1)&#123;            return intervals;        &#125;        //1 按照区间起始位置排序        /**        如果v1[0]-v2[0]为正，代表v1与v2交换位置，故这是升序排序        */        Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);        //2 设定start end指针        int start = intervals[0][0];        int end = intervals[0][1];        //3 循环算法策略        List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();        for(int i = 1;i&lt;intervals.length;i++)&#123;            if(end&gt;=intervals[i][0])&#123;                end = Math.max(end,intervals[i][1]);            &#125;            else&#123;                ans.add(new int[]&#123;start,end&#125;);                start = intervals[i][0];                end = intervals[i][1];            &#125;        &#125;        //4 最后一个区间加一下        ans.add(new int[]&#123;start,end&#125;);        int[][]res = new int[ans.size()][2];        return ans.toArray(res);    &#125;&#125;</code></pre><h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><h2 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1 算法思想"></a>1 算法思想</h2><p>&emsp;&emsp;本质与合并区间没有什么不同，这里是求没有重叠区间的数目，那么在<code>end</code>指针的更新策略不是取最大，而是取最小。</p><p>区别在第<code>3</code>步</p><ol><li>循环遍历，如果当前的<code>end</code>大于下一个区间的起点，那么说明两个区间有交集了，<code>end</code>更新，更新策略为当前<code>end</code>与下一个区间终点的最大值</li></ol><pre><code class="lang-java">List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();for(int i = 1;i&lt;intervals.length;i++)&#123;    //&gt;=号也要变成&gt;,因为区间刚好相“切”是表明不重叠    if(end&gt;intervals[i][0])&#123;        //这里换成min        //当前end大于下一个区间的起点，那么就是说明交叉了        //end更新        end = Math.min(end,intervals[i][1]);        cnt++;    &#125;    else&#123;        end = intervals[i][1];    &#125;&#125;</code></pre><h2 id="2-完整代码-1"><a href="#2-完整代码-1" class="headerlink" title="2 完整代码"></a>2 完整代码</h2><ul><li>start指针没有用，但是写出</li></ul><pre><code class="lang-java">class Solution &#123;    public int eraseOverlapIntervals(int[][] intervals) &#123;        if(intervals.length==1)&#123;            return 0;        &#125;        //按照区间起始位置排序        Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);        //2         int start = intervals[0][0];        int end = intervals[0][1];        int cnt = 0;        for(int i = 1;i&lt;intervals.length;i++)&#123;            if(end&gt;intervals[i][0])&#123;                //当前end大于下一个区间的起点，那么就是说明交叉了                //end更新                end = Math.min(end,intervals[i][1]);                cnt++;            &#125;else&#123;                start = intervals[i][0];                end = intervals[i][1];            &#125;        &#125;        //cnt表示重叠的数目        return cnt;    &#125;&#125;</code></pre><h1 id="戳气球问题"><a href="#戳气球问题" class="headerlink" title="戳气球问题"></a>戳气球问题</h1><blockquote><p>本质是计算无重叠区间问题，不过需要注意的是这里的区间相切，视作区间重叠，故代码的<code>&gt;</code>又得换回<code>&gt;=</code>拿最终的长度减去重叠的数目返回即可</p></blockquote><h2 id="1-完整代码"><a href="#1-完整代码" class="headerlink" title="1 完整代码"></a>1 完整代码</h2><pre><code class="lang-java">class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        //一样的套路，排序右边界        if(points.length&lt;=1)&#123;            return 1;        &#125;        Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0]));        //2         int start = points[0][0];        int end = points[0][1];        int cnt = 0;        for(int i = 1;i&lt;points.length;i++)&#123;            if(end&gt;=points[i][0])&#123;                //当前end大于等于下一个区间的起点，那么就是说明交叉了                //end更新                end = Math.min(end,points[i][1]);                cnt++;            &#125;else&#123;                start = points[i][0];                end = points[i][1];            &#125;        &#125;        //cnt表示重叠的数目        return points.length-cnt;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对力扣的区间类题目做一个总结！&lt;/p&gt;
&lt;h1 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h1&gt;&lt;h2 id=&quot;1-算法思想&quot;&gt;&lt;a href=&quot;#1-算法思想&quot; class=&quot;h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践4: 流量过滤</title>
    <link href="https://lulu-cloud.github.io/2023/04/01/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-2%EF%BC%9A%E8%BF%87%E6%BB%A4/"/>
    <id>https://lulu-cloud.github.io/2023/04/01/流量预处理-2：过滤/</id>
    <published>2023-04-01T13:27:14.000Z</published>
    <updated>2023-11-24T13:56:04.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践4：流量过滤"><a href="#加密流量分类-实践4：流量过滤" class="headerlink" title="加密流量分类-实践4：流量过滤"></a>加密流量分类-实践4：流量过滤</h1><ul><li>炼丹的时候，经常需要过滤无关流量</li><li>论文的通常做法是将dns、icmp、arp、tcp握手报文删除</li><li><p>以下是给出我的代码，用wirshark前后对比pcap有效</p><pre><code class="lang-python">  from scapy.all import *  from scapy.layers.dns import DNS  from scapy.layers.inet import ICMP, TCP  from scapy.layers.l2 import ARP  def remove_pcap_errors(file_path,new_path):      &quot;&quot;&quot;过滤的pcap与新的pcap不冲突&quot;&quot;&quot;      packets = rdpcap(file_path)      dns_cnt = 0      icmp_cnt = 0      arp_cnt = 0      tcp_flags = 0      new_packets = []      for packet in packets:          if packet.haslayer(DNS):              dns_cnt+=1          elif packet.haslayer(ICMP):              icmp_cnt += 1          elif packet.haslayer(TCP) and (packet[TCP].flags.value==0x12 or packet[TCP].flags.value==0x02 or packet[TCP].flags.value==0x11):              tcp_flags+=1          elif packet.haslayer(ARP):              arp_cnt += 1          else:              new_packets.append(packet)      wrpcap(new_path, new_packets)      print(&quot;dns:&#123;&#125;个&quot;.format(dns_cnt))      print(&quot;icmp:&#123;&#125;个&quot;.format(icmp_cnt))      print(&quot;tcp握手:&#123;&#125;个&quot;.format(tcp_flags))      print(&quot;arp包:&#123;&#125;个&quot;.format(arp_cnt))</code></pre></li><li>处理前：<br>-<img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242148352.png" alt="在这里插入图片描述"></li><li>处理后：<br>-<img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242148932.png" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践4：流量过滤&quot;&gt;&lt;a href=&quot;#加密流量分类-实践4：流量过滤&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践4：流量过滤&quot;&gt;&lt;/a&gt;加密流量分类-实践4：流量过滤&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;炼丹的时候，经常需要过滤
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践3: 特征提取</title>
    <link href="https://lulu-cloud.github.io/2023/03/11/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-1%EF%BC%9A%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <id>https://lulu-cloud.github.io/2023/03/11/流量预处理-1：特征提取/</id>
    <published>2023-03-11T13:27:14.000Z</published>
    <updated>2023-11-24T13:48:25.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践3：特征提取"><a href="#加密流量分类-实践3：特征提取" class="headerlink" title="加密流量分类-实践3：特征提取"></a>加密流量分类-实践3：特征提取</h1><h2 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h2><p> 看着博客<a href="[flowcontainer: 基于python3的pcap网络流量特征信息提取库_Icoding_F2014的博客-CSDN博客](https://blog.csdn.net/jmh1996/article/details/107148871">flowcontainer</a>)的感觉很好，但是有如下缺陷：</p><ol><li><p>处理大文件费内存，关于数据集ISCX2016中的FT类型一个pcap动则就是5个多G，吃不消</p></li><li><p>设置extension字段提取tcp与udp有效负载时，对于上述的大文件处理特别慢！！！原因是加载所有数据进入内存，但是实际预处理只需要前几个包的有效载荷数据，造成内存大开销！</p></li><li><p>如果有pcap开始的数据报文不是包含有效载荷的报文，如开始为icmp报文的pcap文件，该库会报错，具体溯源已找到：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242147711.png" alt="image-20230309201640624"></p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242147859.png" alt="image-20230309201731035"></p><pre><code>            if protocol in [&#39;tcp&#39;,&#39;udp&#39;] and ip_layer == False:                flowid = packet[1] if protocol==&#39;tcp&#39; else packet[2]                srcport = packet[7] if protocol==&#39;tcp&#39; else packet[8]                dstport = packet[11] if protocol==&#39;tcp&#39; else packet[12]                payload_length = packet[15] if protocol ==&#39;tcp&#39; else packet[16]            else:                flowid = 0                srcport = 1                dstport = 0                # 这一行是加上的，如果不加上，payload_length就会为初始化，导致result的appeend失败，从而在流生成的函数里造成对空对象的迭代遍历                payload_length = &#39;0&#39;</code></pre><blockquote><p>红色圈圈是加上的代码，加上后就不会出现致命异常</p></blockquote></li><li><p>但是依旧是慢！在处理大文件的pcap特别费劲！等个几个小时才读取完！</p></li><li><p>分流与SplitCap.exe的分流有出入，目前论文主流方法分流是使用SplitCap.exe工具</p></li></ol><h2 id="2、预处理功能"><a href="#2、预处理功能" class="headerlink" title="2、预处理功能"></a>2、预处理功能</h2><p>直接上代码：</p><pre><code>import binasciiimport scapy.all as scapyimport numpy as npdef hex_to_dec(hex_str, target_length):    dec_list = []    for i in range(0, len(hex_str), 2):        dec_list.append(int(hex_str[i:i + 2], 16))    dec_list = pad_or_truncate(dec_list, target_length)    return dec_listdef pad_or_truncate(some_list, target_len):    return some_list[:target_len] + [0] * (target_len - len(some_list))def pad_or_truncate_seq(some_list, target_len):    return some_list[:target_len] + [0] * (target_len - len(some_list))# 获取流的长度、方向、到达时间序列# 一个字节8位，占两个十六进制数字def get_seq_feature(pcap_path, pack_nums=4, byte_nums=128, seq_length=128, throw=3):    &quot;&quot;&quot;    读取分流好的pcap文件，返回它的ip报文长度、到达时间序列与前pack_num个报文的前byte_num字节的负载    &quot;&quot;&quot;    packets = scapy.rdpcap(pcap_path)    ip_lengths = []    ip_arrive_time = []    pay_load = []    pay_index = []    if len(packets) &lt;= throw:        return ip_lengths, ip_arrive_time, pay_load,pay_index    dic = &#123;&#125;    pay_num = 0    for i, packet in enumerate(packets):        # 提取包长序列        if i == 0:            dst = packet.src            src = packet.dst            dic = &#123;dst: -1, src: 1&#125;        dst = packet.dst        ip_length = dic[dst] * len(packet)        ip_lengths.append(ip_length)        # 包到达时间提取        ip_arrive_time.append(float(packet.time))        # 提取负载与负载在流中包的序号        if len(packet.payload.payload) != 0:            if pay_num &lt; pack_nums:                pay = packet.payload.payload                # print(type(pay))                # print(pay)                data = (binascii.hexlify(bytes(pay)))                data = hex_to_dec(data, target_length=byte_nums)                pay_load.extend(data)                pay_index.append(i+1)                pay_num += 1    if len(pay_index)&lt;pack_nums:        # 不足        for i in range(pack_nums-len(pay_index)):            data = hex_to_dec([],byte_nums)            pay_load.extend(data)            pay_index.append(-1)    ip_lengths = pad_or_truncate_seq(ip_lengths, seq_length)    ip_arrive_time = pad_or_truncate_seq(ip_arrive_time, seq_length)    return ip_lengths, ip_arrive_time, pay_load, pay_index</code></pre><ul><li><p>首先输入是预处理分流好的pcap文件，使用SplitCap.exe分流即可</p><ul><li>函数参数解释</li></ul><pre><code>pack_nums：提取前几个包的负载byte_nums：提取包的前几个字节的负载seq_length：提取流的前几个包的长度（正负表示方向）throw：表示流中的包少于多少个不处理</code></pre><ul><li><p>输出：</p><ul><li><p>包长度</p></li><li><p>包到达时间</p></li><li><p>包负载</p></li><li><p>前几个负载包的流中的序号</p></li></ul></li></ul></li></ul><blockquote><p>上述都是短则补0，长则截断</p></blockquote><p>不会有内存不足的问题辣，处理负载也很快，因为不看报头，所以不需要什么匿名ip，mac地址啥的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践3：特征提取&quot;&gt;&lt;a href=&quot;#加密流量分类-实践3：特征提取&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践3：特征提取&quot;&gt;&lt;/a&gt;加密流量分类-实践3：特征提取&lt;/h1&gt;&lt;h2 id=&quot;1、原因&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践2: CNN+LSTM模型训练与测试</title>
    <link href="https://lulu-cloud.github.io/2023/03/09/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BBtorch%E5%AE%9E%E8%B7%B52%EF%BC%9ACNN+LSTM%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://lulu-cloud.github.io/2023/03/09/加密流量分类torch实践2：CNN+LSTM模型训练与测试/</id>
    <published>2023-03-09T13:27:14.000Z</published>
    <updated>2023-11-25T04:08:46.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类torch实践2：CNN-LSTM模型训练与测试"><a href="#加密流量分类torch实践2：CNN-LSTM模型训练与测试" class="headerlink" title="加密流量分类torch实践2：CNN+LSTM模型训练与测试"></a>加密流量分类torch实践2：CNN+LSTM模型训练与测试</h1><ul><li>代码模板参考：<a href="https://github.com/lulu-cloud/Traffic-Classification">CENTIME:A Direct Comprehensive Traffic Features Extraction for Encrypted Traffic Classification</a></li></ul><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><ul><li>一维卷积处理负载数据，处理流前n个包的前m个字节</li><li>Bi-LSTM处理包长序列，取流前seq_length的长度序列</li><li>模型结构类似于APP-Net<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142143.png" alt=""></li><li><p>模型代码：<br>~~~<br>  “””<br>  cnn处理负载<br>  lstm处理包长序列<br>  “””</p><p>  import torch<br>  import torch.nn as nn</p></li></ul><pre><code>class Cnn_Lstm(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Cnn_Lstm, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.cnn_feature = nn.Sequential(            nn.Conv1d(kernel_size=25, in_channels=1, out_channels=32, stride=1, padding=12),  # (1,1024)-&gt;(32,1024)            nn.BatchNorm1d(32),  # 加上BN的结果            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (32,1024)-&gt;(32,342)            nn.Conv1d(kernel_size=25, in_channels=32, out_channels=64, stride=1, padding=12),  # (32,342)-&gt;(64,342)            nn.BatchNorm1d(64),            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (64,342)-&gt;(64,114)        )        self.cnn_classifier = nn.Sequential(            # 64*114            nn.Flatten(),            nn.Linear(in_features=64*114, out_features=1024), # 784:88*64, 1024:114*64, 4096:456*64        )        self.cnn=nn.Sequential(            self.cnn_feature,            self.cnn_classifier,        )        self.rnn = nn.Sequential(            nn.LSTM(input_size, hidden_size, num_layers, bidirectional=bidirectional, batch_first=True),        )        self.classifier=nn.Sequential(            nn.Linear(in_features=2048,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_payload=self.cnn(x_payload)        x_sequence=self.rnn(x_sequence)        x_sequence=x_sequence[0][:, -1, :]        x=torch.cat((x_payload,x_sequence),1)        x=self.classifier(x)        return xdef cnn_rnn(model_path, pretrained=False, **kwargs):    model = Cnn_Lstm(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return modelclass Cnn(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Cnn, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.cnn_feature = nn.Sequential(            nn.Conv1d(kernel_size=25, in_channels=1, out_channels=32, stride=1, padding=12),  # (1,1024)-&gt;(32,1024)            nn.BatchNorm1d(32),  # 加上BN的结果            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (32,1024)-&gt;(32,342)            nn.Conv1d(kernel_size=25, in_channels=32, out_channels=64, stride=1, padding=12),  # (32,342)-&gt;(64,342)            nn.BatchNorm1d(64),            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (64,342)-&gt;(64,114)        )        self.cnn_classifier = nn.Sequential(            # 64*114            nn.Flatten(),            nn.Linear(in_features=64*114, out_features=1024), # 784:88*64, 1024:114*64, 4096:456*64        )        self.cnn=nn.Sequential(            self.cnn_feature,            self.cnn_classifier,        )        self.classifier=nn.Sequential(            nn.Linear(in_features=1024,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_payload=self.cnn(x_payload)        x=self.classifier(x_payload)        return x_payloaddef cnn(model_path, pretrained=False, **kwargs):    model = Cnn(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return modelclass Lstm(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Lstm, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.rnn = nn.Sequential(            nn.LSTM(input_size, hidden_size, num_layers, bidirectional=bidirectional, batch_first=True),        )        self.classifier=nn.Sequential(            nn.Linear(in_features=1024,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_sequence=self.rnn(x_sequence)        x_sequence=x_sequence[0][:, -1, :]        x=self.classifier(x_sequence)        return xdef rnn(model_path, pretrained=False, **kwargs):    model = Lstm(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return model</code></pre><pre><code>## 2、运行- 在自己的环境下修改路径，包括删除``from sequence_payload.xx import xx``下面的``sequence_payload.``- 修改配置文件``entry``下面的``traffic_classification.yaml``的路径，与模型参数，名字  - 训练流程代码</code></pre><p>from utils.helper import AverageMeter, accuracy<br>from TrafficLog.setLog import logger</p><p>def train_process(train_loader, model, criterion, optimizer, epoch, device, print_freq):<br>    “””训练一个 epoch 的流程</p><pre><code>Args:train_loader (dataloader): [description]model ([type]): [description]criterion ([type]): [description]optimizer ([type]): [description]epoch (int): 当前所在的 epochdevice (torch.device): 是否使用 gpuprint_freq ([type]): [description]&quot;&quot;&quot;losses = AverageMeter()  # 在一个 train loader 中的 loss 变化top1 = AverageMeter()  # 记录在一个 train loader 中的 accuracy 变化model.train()  # 切换为训练模型for i, (pcap, seq,target) in enumerate(train_loader):    pcap = pcap.reshape(-1,1,1024)    seq = seq.reshape(-1,64,1)    pcap = pcap.to(device)    seq = seq.to(device)    target = target.to(device)    output = model(pcap,seq)  # 得到模型预测结果    loss = criterion(output, target)  # 计算 loss    prec1 = accuracy(output.data, target)    losses.update(loss.item(), pcap.size(0))    top1.update(prec1[0].item(), pcap.size(0))    optimizer.zero_grad()    loss.backward()    optimizer.step()    if (i+1) % print_freq == 0:        logger.info(&#39;Epoch: [&#123;0&#125;][&#123;1&#125;/&#123;2&#125;], Loss &#123;loss.val:.4f&#125; (&#123;loss.avg:.4f&#125;), Prec@1 &#123;top1.val:.3f&#125; (&#123;top1.avg:.3f&#125;)&#39;.format(        epoch, i, len(train_loader), loss=losses, top1=top1))return losses.val,top1.val</code></pre><pre><code>  - 验证流程代码： - ## 2.1 数据预处理原理：- 使用flowcontainer包提取含有tcp或者udp负载的包，提取负载与ip数据包序列长度&lt;br/&gt;使用：- 将原始pcap文件放在``traffic_data``下  - 格式:</code></pre><pre><code>|---traffic_data  |---bilibili    |--- xx.pcap    |--- xxx.pcap  |---qq    |--- xx.pcap    |--- xxx.pcap  |--- 今日头条    |--- xx.pcap    |--- xxx.pcap</code></pre><p>  ~~~</p><ul><li>运行<code>entry/preprocess.py</code>,完成后复制控制台输出的<strong>label2index</strong>,粘贴到<code>traffic_classification.yaml/test/traffic_classification.yaml</code></li><li>得到处理好的  <code>npy_data</code><h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2></li><li><p>打开<code>entry/train.py</code>，注释或者取消注释40、41、42行，选择cnn、lstm、cnn+lstm进行训练，记得改配置文件的<code>model_name</code></p></li><li><p>可以打开tensorboard查看loss与acc曲线</p><ul><li>loss:<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142078.png" alt="在这里插入图片描述"></li></ul></li></ul><ul><li>acc:<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142864.png" alt="在这里插入图片描述"></li></ul><pre><code>&gt; 两图为lstm处理序列数据的tensorboard示例</code></pre><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><ul><li>修改<code>traffic_classification.yaml/test/evaluate</code>为True，打开<code>entry/train.py</code>运行，得到评估结果<br>/evaluate<code>为True，打开</code>entry/train.py``运行，得到评估结果<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142556.png" alt="在这里插入图片描述"><br>项目地址：<a href="https://github.com/lulu-cloud/TrafficClassificationTemplate">lulu-cloud</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类torch实践2：CNN-LSTM模型训练与测试&quot;&gt;&lt;a href=&quot;#加密流量分类torch实践2：CNN-LSTM模型训练与测试&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类torch实践2：CNN+LSTM模型训练与测试&quot;&gt;
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：二分查找</title>
    <link href="https://lulu-cloud.github.io/2023/03/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://lulu-cloud.github.io/2023/03/02/力扣刷题-二分查找/</id>
    <published>2023-03-02T01:27:18.000Z</published>
    <updated>2024-04-13T09:21:12.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-原则"><a href="#一、-原则" class="headerlink" title="一、 原则"></a>一、 原则</h1><h2 id="1-区间：左右闭区间"><a href="#1-区间：左右闭区间" class="headerlink" title="1. 区间：左右闭区间"></a>1. 区间：左右闭区间</h2><h2 id="2-while结束设定为-lt"><a href="#2-while结束设定为-lt" class="headerlink" title="2. while结束设定为&lt;="></a>2. while结束设定为&lt;=</h2><h2 id="3-左右界更新都为mid上下1"><a href="#3-左右界更新都为mid上下1" class="headerlink" title="3. 左右界更新都为mid上下1"></a>3. 左右界更新都为mid上下1</h2><blockquote><ol><li><p>二分查找可以设定左闭右开的写法，也可以左右都是闭区间，这里设定后者</p></li><li><p>在1的设定下，如果left=right，即当前搜索区间长度为1，如果while里面不是&lt;=二是严格&lt;,那么该长度为1的区间就不会搜索，出现遗漏</p></li><li><p>在1，2的设定之下，必须让left、right的更新机制在循环结束后，right在left的左边，即每次更新right与left必须都不能为mid，因为mid可能 在区间长度为1或者2的时候mid等于其中的left，必须使得right与left有机制在更新时不能一直等于mid，故有原则3</p></li></ol></blockquote><h1 id="二、三种情况"><a href="#二、三种情况" class="headerlink" title="二、三种情况"></a>二、三种情况</h1><h2 id="2-1-直接找元素"><a href="#2-1-直接找元素" class="headerlink" title="2.1 直接找元素"></a>2.1 直接找元素</h2><pre><code class="lang-java">int searchBinary(int[] nums, int target) &#123;    //原则1 左右闭区间    int left = 0, right = nums.length - 1;    //原则2 while结束条件为&lt;=    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            //原则3 左右界更新为mid加减1            left = mid + 1;        &#125; else &#123;            //原则3 左右界更新为mid加减1            right = mid - 1;        &#125;    &#125;    return -1;&#125;</code></pre><h2 id="2-2-寻找左右边界"><a href="#2-2-寻找左右边界" class="headerlink" title="2.2 寻找左右边界"></a>2.2 寻找左右边界</h2><p>给定有序数组</p><script type="math/tex; mode=display">[0,1,2,2,2,3,4]</script><p>如何找第一个2出现的下标或者最后一个2出现的下标</p><ul><li>找第一个：找左边界</li></ul><pre><code class="lang-java">int searchLeftBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            right = mid - 1; // 收缩右边界        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    // 越界检查，不存在检查    if (left &gt;= nums.length || nums[left] != target) &#123;        return -1;    &#125;    return left;&#125;</code></pre><ul><li>找最后一个：找右边界</li></ul><pre><code class="lang-java">int searchRightBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            left = mid + 1; // 收缩左边界        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    if (right &lt; 0 || nums[right] != target) &#123;        return -1;    &#125;    return right;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、-原则&quot;&gt;&lt;a href=&quot;#一、-原则&quot; class=&quot;headerlink&quot; title=&quot;一、 原则&quot;&gt;&lt;/a&gt;一、 原则&lt;/h1&gt;&lt;h2 id=&quot;1-区间：左右闭区间&quot;&gt;&lt;a href=&quot;#1-区间：左右闭区间&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文12: Seeing Traffic Paths_ Encrypted Traffic Classification With Path Signature Features</title>
    <link href="https://lulu-cloud.github.io/2023/01/19/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%8712%EF%BC%9ASeeing%20Traffic%20Paths_%20Encrypted%20Traffic%20Classification%20With%20Path%20Signature%20Features/"/>
    <id>https://lulu-cloud.github.io/2023/01/19/加密流量分类-论文12：Seeing Traffic Paths_ Encrypted Traffic Classification With Path Signature Features/</id>
    <published>2023-01-19T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:57.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><p>&emsp;&emsp;本文提出了一种新的带路径签名的加密流分类方法——ETC-PS。首先用<strong>会话数据包长度序列</strong>构造<strong>流量路径</strong>来表示客户端和服务器之间的交互。然后进行<strong>路径变换</strong>，展示其结构，获得不同的信息。最后计算出多尺度路径特征作为一种显著特征来训练传统的<strong>机器学习</strong>分类器，实现了高鲁棒精度和低训练开销。</p><h1 id="1、模型方法"><a href="#1、模型方法" class="headerlink" title="1、模型方法"></a>1、模型方法</h1><ul><li><p>将<strong>路径签名</strong>应用与加密流量分类，只使用了流量的序列特征。</p><ol><li>机器学习分类：要走数据预处理、特征工程、分类等过程，相交于深度学习方法多了特征工程</li><li>特征工程：从会话中客户端-服务器双向交互的流量特征构建了流量路径，再进行路径变换，作为分类器输入</li></ol><h2 id="1-1-路径签名定义与科普"><a href="#1-1-路径签名定义与科普" class="headerlink" title="1.1 路径签名定义与科普"></a>1.1 路径签名定义与科普</h2></li></ul><h3 id="1-1-1科普"><a href="#1-1-1科普" class="headerlink" title="1.1.1科普"></a>1.1.1科普</h3><p>参考<a href="[Path Signature笔记 - 知乎 (zhihu.com"><a href="https://zhuanlan.zhihu.com/p/335494125">Path Signature笔记 - 知乎 (zhihu.com)</a></a>](<a href="https://zhuanlan.zhihu.com/p/335494125">https://zhuanlan.zhihu.com/p/335494125</a>))</p><h3 id="1-1-2-路径签名的一些性质"><a href="#1-1-2-路径签名的一些性质" class="headerlink" title="1.1.2 路径签名的一些性质"></a>1.1.2 路径签名的一些性质</h3><ul><li><strong>唯一性</strong>：<strong>由路径签名可以完全确定一个路径，</strong>具有单调维度的路径(如时间)没有支路部分。因此，对于一个加密的流量报文长度序列(一维路径)，通常需要添加一个单调递增的维度(例如时间)，以保证路径签名可以等价地确定它</li><li><strong>重新参数化不变性：</strong> <strong>对于一个路径，采用不同的采样频率得到的路径表示会不同，但是路径签名不会变。</strong>对于特定类型应用程序生成的流量，分类结果应该不受不同重参数化的影响。有了这个特性，签名可以过滤掉同种流量的不同重参数化引起的变化，不会分为不同应用。</li><li><strong>维数固定:</strong> <strong>从整个路径中提取的路径特征的维数取决于截断级别，与路径长度无关。</strong>再短的路径其签名维数也是无限长，使用的时候取决于我们截断的维度是多少。</li></ul><h2 id="1-2-ETC-PS整体预览"><a href="#1-2-ETC-PS整体预览" class="headerlink" title="1.2 ETC-PS整体预览"></a>1.2 ETC-PS整体预览</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242128763.png" alt="image-20230119105316076"></p><ol><li>收集报文序列，计算报文长度，生成报文长度序列，使用正负号表示报文序列的不同方向</li><li>进行路径构造</li><li>进行路径变换</li><li>进行路径签名特征提取得到特征</li><li>使用机器学习分类器进行分类</li></ol><h2 id="1-3-流量路径构造"><a href="#1-3-流量路径构造" class="headerlink" title="1.3 流量路径构造"></a>1.3 流量路径构造</h2><h3 id="1-3-1-客户端与服务器的双向交互"><a href="#1-3-1-客户端与服务器的双向交互" class="headerlink" title="1.3.1 客户端与服务器的双向交互"></a>1.3.1 客户端与服务器的双向交互</h3><p>&emsp;&emsp;当客户端和服务器之间建立连接时，客户端通常会向服务器发送请求，请求服务器发送所需的资源。主要分为3个阶段</p><ul><li><p>握手阶段：上行和下行报文在此阶段交替传输。对于同一种传输协议，在此阶段生成的报文序列非常相似，包括报文长度、数量、方向等。（<strong>有明显特征</strong>）</p></li><li><p>上行报文主导阶段：上行报文（C-&gt;S）主要在此阶段传输。通常将控制指令编码的上行报文发送给服务器，邀请服务器配合提高数据传输效率。</p></li><li><p>下行报文主导阶段：下行报文（S-&gt;C）主要在此阶段传输。下行报文用于传输客户端所需要的内容</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242128673.png" alt="image-20230119105857080"></p></li></ul><h3 id="1-3-2-网络流量路径构建"><a href="#1-3-2-网络流量路径构建" class="headerlink" title="1.3.2 网络流量路径构建"></a>1.3.2 网络流量路径构建</h3><p>&emsp;&emsp;其实就是将流量报文长度序列收集起来，生成原始序列S,即一条一维路径，也就是流量路径X<sub>t</sub><sup>0</sup>其中上标0表示这是原始流量路径。</p><blockquote><p>给出代码提取报文长度序列，（无关原文）使用代码提取ip数据报文长度序列如下</p></blockquote><pre><code>from flowcontainer.extractor import extractpcap_path = r&quot;XX.pcap&quot;result = extract(pcap_path)for i , key in enumerate(result):    print(&quot;flow&#123;&#125;&quot;.format(i))    value = result[key]    print(&#39;ip lengths :&#39;,value.ip_lengths)    print(&#39;\n&#39;)</code></pre><h2 id="1-4-路径转换"><a href="#1-4-路径转换" class="headerlink" title="1.4 路径转换"></a>1.4 路径转换</h2><p>&emsp;&emsp;在大多数情况下，一维流量路径的路径特征往往不够有效，无法达到较高的分类精度。</p><h3 id="1-4-1-路径分解变换"><a href="#1-4-1-路径分解变换" class="headerlink" title="1.4.1 路径分解变换"></a>1.4.1 路径分解变换</h3><ul><li><p>路径分解变换将一条路径转化为相同维数的子路径集合</p><ul><li><p>一维路径X<sub>t</sub><sup>0</sup>首先分解为上行序列路径U<sub>0</sub>与下行序列路径D<sub>0</sub></p></li><li><p>此时变为<strong>二维路径</strong>X<sub>t</sub><sup>0,d</sup>={U,D},上标d表示进行的解体变换，将另一个方向的数据包长度替换为0，即X<sub>t</sub><sup>0，d</sup>中上行序列U的报文长度全替换为0</p></li></ul></li></ul><blockquote><p>变换理由：为了提高路径签名特征的效率，将流量路径转换为两条一维流量路径，这也符合客户端-服务器交互的特点。</p></blockquote><h3 id="1-4-2-累积和变换"><a href="#1-4-2-累积和变换" class="headerlink" title="1.4.2 累积和变换"></a>1.4.2 累积和变换</h3><p>&emsp;&emsp;一般来讲，报文要传输的有效载荷通常是固定的，用于相同的网站或服务，这导致非常相似的累积和特征。</p><p>对于U0序列，累积和可如下表示：</p><script type="math/tex; mode=display">U'=(u_1',u_2',...,u_n'),u_n'=\sum_{i=1}^ku_i</script><p>D0序列类似</p><ul><li>于是变换为<strong>四维</strong>，X<sub>t</sub><sup>0,d,c</sup>={U,D,U’,D’}</li></ul><blockquote><p>变换理由：要传输的有效载荷对于同一网站或服务往往是固定的,使用累积和变换来暴露流量路径的一些内部特征。</p></blockquote><h3 id="1-4-3-基准点变换"><a href="#1-4-3-基准点变换" class="headerlink" title="1.4.3 基准点变换"></a>1.4.3 基准点变换</h3><p>使用函数f</p><script type="math/tex; mode=display">f(X_t)=(0,x_1,...,x_n)</script><p>只是在路径的开头添加了一个0,这种转换使签名对路径的转换敏感，即消除了转换不变性，这对加密流量分类有利，因为不同的数据包大小代表不同的网站布局或服务内容</p><p>得到X<sub>t</sub><sup>0,d,c,b</sup>={f(U),f(D),f(U’),f(D’)}</p><blockquote><p>变换理由：原路径签名特征具有平移不变性，但加密流分类问题不需要这一属性，因此使用基点变换对流量路径进行变换。</p></blockquote><h3 id="1-4-4-结合时间变换"><a href="#1-4-4-结合时间变换" class="headerlink" title="1.4.4 结合时间变换"></a>1.4.4 结合时间变换</h3><ul><li>通过添加单调坐标(如时间)来丰富原有的线性路径，从而保证签名的唯一性。它通常对应于添加时间参数化作为路径坐标。</li><li>将交通路径5维路径X<sub>t</sub><sup>0,d,c,b,t</sup>={f(U),f(D),f(U’),f(D’),t<blockquote><p>变换理由：保证构建的流量路径具有唯一性</p></blockquote></li></ul><h2 id="1-5-路径特征抽取"><a href="#1-5-路径特征抽取" class="headerlink" title="1.5 路径特征抽取"></a>1.5 路径特征抽取</h2><ul><li><p>使用滑动窗口机制进行<strong>多尺度</strong>特征抽取</p><ul><li>提取分层特征，设置q层，有q个滑动窗口，对于第i层的滑动窗口W<sub>i</sub>,窗口长度与步长都是n2<sup>i-1</sup>，这将产生2<sup>q</sup>-1个子路径，自路径长度分别为n,n/2,n/4,…,n/2<sup>q-1</sup><ul><li>即对于第一层，窗口长度为n，步长为n，产生2^0=1个子路径</li><li>对于第二层，窗口与步长都是n/2, 产生2^1=1个子路径</li><li>对于第三层，窗口与步长都是n/4，产生2^2=4个子路径</li><li>……</li><li>对于第q层，产生2^q-1个子路径<br>故总的路径数目为<script type="math/tex; mode=display">2^0 +2^1 + ···+2^{q-1}=2^q-1</script>&emsp;&emsp;然后对于这2^q-1个子路径进行计算路径签名，作为分类器输入特征</li></ul></li><li><p>整体流程如下所示：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129402.png" alt="image-20230119114153356"></p></li></ul></li><li><p>图中CS Sequence表示累积和系列</p></li></ul><hr><h1 id="2、实验"><a href="#2、实验" class="headerlink" title="2、实验"></a>2、实验</h1><h2 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h2><p> <img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129771.png" alt=""></p><h2 id="2-2-预处理"><a href="#2-2-预处理" class="headerlink" title="2.2 预处理"></a>2.2 预处理</h2><ul><li>分为session双向流，提取数据包长度</li><li>标记</li><li>过滤：对于流太短的，只有几个包，剔除；类别样本数目太少的，剔除</li></ul><h2 id="2-3-调参"><a href="#2-3-调参" class="headerlink" title="2.3 调参"></a>2.3 调参</h2><ul><li><p>序列长度：40</p></li><li><p>236个类别，每个类别45个样本</p></li></ul><h3 id="2-3-1-序列选择的调整"><a href="#2-3-1-序列选择的调整" class="headerlink" title="2.3.1 序列选择的调整"></a>2.3.1 序列选择的调整</h3><p>&emsp;&emsp;上文变换后的X<sub>t</sub><sup>0,d,c,b</sup>={f(U),f(D),f(U’),f(D’)}由四个一维序列组成，但是文中有六个序列，进行排列组合变换，找出最佳变换；</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129092.png" alt="image-20230119115903416"></p><p>最后选择选择U0序列、D0序列、U0 CS序列和D0 CS序列的组合路径，也就是段落1提到的路径组合。</p><h3 id="2-3-2-分类器选择"><a href="#2-3-2-分类器选择" class="headerlink" title="2.3.2 分类器选择"></a>2.3.2 分类器选择</h3><p>选RF随机森林</p><h3 id="2-3-3-参数选择"><a href="#2-3-3-参数选择" class="headerlink" title="2.3.3 参数选择"></a>2.3.3 参数选择</h3><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129145.png" alt="在这里插入图片描述"></p><p>签名深度为3<br>窗口深度q为4</p><blockquote><ul><li>关于序列长度增长，acc降低的分析：序列长度越长，路径包含的信息就越丰富，这就对模型提取特征的能力提出了更高的要求，而固定深度的路径签名和窗口窗口深度代表了固定的模型能力，随着序列长度增加，acc降低正常</li><li>路径签名的深度：在窗口深度为2的情况下，随着序列长度从40增加到200，精度之间的差距将逐渐明显，其中深度大的情况总是优于深度小的情况。因为路径签名深度大代表高阶psf，其中包含更多的路径细节。</li><li>窗口深度：当分层窗口深度从2增加到4时，准确率会逐渐提高。然而，大深度的分层窗口会导致PSF维度爆炸，并导致较高的计算成本。<br>……<h2 id="2-4-在开放世界数据的效果"><a href="#2-4-在开放世界数据的效果" class="headerlink" title="2.4 在开放世界数据的效果"></a>2.4 在开放世界数据的效果</h2><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129899.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="3、总结与思考"><a href="#3、总结与思考" class="headerlink" title="3、总结与思考"></a>3、总结与思考</h1><p>缺陷：数据包填充技术会使得基于序列特征的方法失效。</p><p>&emsp;将深度学习应用于带路径签名的加密流分类是一个很有前景的研究方向，尤其是RNN。路径签名特征在移动加密流分类问题中的应用也很值得探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文提出了一种新的带路径签名的加密流分类方法——ETC-PS。首先用&lt;strong&gt;会话数据包长度序
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文11: FlowPic_ A Generic Representation for Encrypted Traffic Classification and Applications</title>
    <link href="https://lulu-cloud.github.io/2022/11/18/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%8711%20FlowPic_%20A%20Generic%20Representation%20for%20Encrypted%20Traffic%20Classification%20and%20Applications/"/>
    <id>https://lulu-cloud.github.io/2022/11/18/加密流量分类-论文11 FlowPic_ A Generic Representation for Encrypted Traffic Classification and Applications/</id>
    <published>2022-11-18T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:54.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><p>&emsp;&emsp;利用了流中与<strong>时间</strong>相关和与大小相关的特性，将基本流量数据转换为直观的图片FlowPic，然后使用已知的图像分类深度学习技术cnn来识别流量类别(浏览、聊天、视频等)和正在使用的应用程序。<strong>但是不是使用负载数据形成的特征图。</strong></p><h1 id="1、介绍"><a href="#1、介绍" class="headerlink" title="1、介绍"></a>1、介绍</h1><p>&emsp;&emsp;对于每个流，我们的方法根据数据包大小和数据包到达时间创建一个图像，我们称之为FlowPic。</p><ul><li>不依赖于数据包有效负载内容，因此不会侵犯隐私</li><li>存储需求非常小，分类速度块，近乎实时，可以进行在线的流量分类</li></ul><h1 id="2、数据集介绍"><a href="#2、数据集介绍" class="headerlink" title="2、数据集介绍"></a>2、数据集介绍</h1><ul><li><p>数据集：ISCX VPN-nonVPN、ISCX Tor-nonTor、作者团队自己捕获的数据集（命名为TAU）</p></li><li><p>分类标签类别：</p><ol><li><p>VoIP</p></li><li><p>Video</p></li><li><p>Chat</p></li><li><p>File Transfer</p></li><li><p>Browsing</p></li></ol></li></ul><p>因此，对于五个类别，三种加密技术(非VPN、VPN、Tor)，相当于15种流量。</p><blockquote><p>显然这是关于流量类型识别</p></blockquote><h2 id="2-1-数据处理"><a href="#2-1-数据处理" class="headerlink" title="2.1 数据处理"></a>2.1 数据处理</h2><p>&emsp;&emsp;主要是写作者自己数据的收集的一些细节。</p><h2 id="2-2-数据增强"><a href="#2-2-数据增强" class="headerlink" title="2.2 数据增强"></a>2.2 数据增强</h2><ul><li><p>单向流分大小相等的块，实验中为每隔60s分为一个块</p></li><li><p>但是为了进行数据增强，就将两个块之间进行重叠，重叠时间设置为45秒，这样块与块之间的间隔为15秒</p><blockquote><p>数据扩充过程是在将所有会话分割为一个训练集和一个测试集之后进行的，确保训练块和测试块之间在单个会话中没有重叠</p></blockquote></li></ul><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127932.png" alt="image-20221118194010907"></p><p>（数据增广后的每个类别的样本数目）</p><h2 id="2-3-敏感性分析"><a href="#2-3-敏感性分析" class="headerlink" title="2.3 敏感性分析"></a>2.3 敏感性分析</h2><p>关于数据增强是否真的有效？块长大小为多少合适？</p><p>结论：</p><ol><li>在个别的流量类型里，数据增强效果不明显</li><li><p>60s的块大小最合适</p><h1 id="3-构建图像"><a href="#3-构建图像" class="headerlink" title="3 构建图像"></a>3 构建图像</h1></li></ol><h2 id="3-1-构建FlowPic"><a href="#3-1-构建FlowPic" class="headerlink" title="3.1 构建FlowPic"></a>3.1 构建FlowPic</h2><ul><li><p>提取每个单向流中的每个数据包的两个特征<strong>IP包大小</strong>、<strong>到达时间</strong></p></li><li><p>构建一个基于流的二维直方图的图像,该图像可以被视为负载大小分布(PSD)</p><ul><li><p>X轴为包的到达时间，Y轴为包的大小</p><blockquote><p>绝大多数包的大小都不超过1500字节(这是以太网MTU值)，将y轴限制在1到1500之间。</p><p>对于x轴，将2d直方图设置为正方形图像。为此，我们将所有到达时间值标准化为0到1500之间(即60秒映射为1500)</p><ul><li>生成1500x1500的直方图，直方图命名为FlowPic，存储在矩阵当中，作为模型输入</li></ul></blockquote></li></ul></li></ul><h2 id="3-2-FlowPic分析"><a href="#3-2-FlowPic分析" class="headerlink" title="3.2 FlowPic分析"></a>3.2 FlowPic分析</h2><p>&emsp;&emsp;这里说了作者在对生成FlowPic的一点分析，从而说明FlowPic能反映出网络流通特征复杂，使用深度神经网络模型进行特征提取并分类是很有必要的。</p><ul><li>分析1：在不同应用下，对视频流的分析：</li></ul><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127831.png" alt="image-20221118195503724"></p><blockquote><p> 不用应用下的流量类型表现不同特性，例如，Netflix传输的数据包大小几乎是固定的，而Skype、Facebook和谷歌Hangout等应用程序传输的大小分布广泛。并且，视频流不仅限于显示元素，还包括行为与VoIP相同的音频流，以及看起来像聊天传输的用于协调和控制的小数据包流。相比之下，例如在Skype上，视频流和音频流是分开的。</p></blockquote><ul><li><p>分析2：加密技术对流量类别的流行为的影响：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127589.png" alt="image-20221118195738482"></p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127465.png" alt="image-20221118195756083"></p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127413.png" alt="image-20221118195807254"></p></li></ul><blockquote><p>在不同的加密技术之间，有些类别的flowpic行为完全不同</p></blockquote><ul><li><p>分析3：Tor的加密技术下，Tor流量的包的大小分布比较离散，从图中可以看出来，与非vpn流量中的许多包大小不同。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127818.png" alt="image-20221118200339300"></p></li></ul><h1 id="4-卷积神经网络结构设计"><a href="#4-卷积神经网络结构设计" class="headerlink" title="4 卷积神经网络结构设计"></a>4 卷积神经网络结构设计</h1><ul><li><p>输入：二维1500x1500图像</p></li><li><p>输出：2或者流量类别（2是判定是否为NonVPN）</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127129.png" alt="image-20221118200711631"></p></li></ul><p><strong>延迟分析</strong>：TBS +TFC +TML</p><ul><li><p>TBS是自定义块大小(15、30或60秒)</p></li><li><p>TFC是FlowPic构建时间</p></li><li><p>TML是执行分类的CNN运行时间。</p><p>&emsp;  &emsp;实验中，我们发现TFC和TML都是0.1 s，与块大小相比可以忽略不计，故可以满足在线分类要求。</p><h1 id="5、实验"><a href="#5、实验" class="headerlink" title="5、实验"></a>5、实验</h1></li></ul><h2 id="5-1-处理样本不平衡问题"><a href="#5-1-处理样本不平衡问题" class="headerlink" title="5.1 处理样本不平衡问题"></a>5.1 处理样本不平衡问题</h2><p>方法：过采样、欠采样</p><h3 id="5-1-1-多类分类情况"><a href="#5-1-1-多类分类情况" class="headerlink" title="5.1.1 多类分类情况"></a>5.1.1 多类分类情况</h3><ol><li><p>流量类型分类（Traffic categorization）：对于三种数据集（非VPN、VPN和Tor）合并其中相同类型的，而不考虑加密技术，动机是研究加密技术如何影响流量行为。</p></li><li><p>加密技术分类：即3分类，识别出是否为非VPN、VPN和Tor三种的某一种流量。</p></li><li><p>应用识别：使用创建的数据集，在<strong>VoIP类型</strong>与<strong>视频类型</strong>下捕获10个应用程序的三种加密方式（非VPN、VPN、Tor）的流量。</p></li></ol><h3 id="5-1-2-一对多的分类情况"><a href="#5-1-2-一对多的分类情况" class="headerlink" title="5.1.2 一对多的分类情况"></a>5.1.2 一对多的分类情况</h3><p>&emsp;&emsp;为3种加密技术构建类与所有数据集:非VPN、VPN(针对所有类，除了browse)和TOR，以及合并数据集。对于每种加密技术，每个流类别合并数据集包含相同数量的会话。</p><blockquote><p>训练测试集比例是 9:1</p></blockquote><ul><li><p>Wang等人<a href="[加密流量分类-论文4Endtoend Encrypted Traffic Classification with One-dimensional Convolution Neural Networks_烟玉蓝田的博客-CSDN博客](https://blog.csdn.net/qq_45125356/article/details/126925196?spm=1001.2014.3001.5501">link</a>)使用每个流的前784字节对ISCX VPN-非VPN数据集上的流量进行分类，并使用不同的表示方法分别对非VPN和VPN流量实现了83.0%和98.6%的最佳准确性。但Wang的实验没有包括浏览类别，因为很难将其与其他类别区分开来。从上图的混淆矩阵可以看出，，难以区分浏览和聊天是导致准确度下降的主要原因。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127937.png" alt="image-20221118202550257"></p></li><li><p>与其他方法的对比</p></li></ul><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242127191.png" alt="image-20221118203401553"></p><blockquote><p>还有很多的实验结果：比如未知流量识别、加密技术分类、应用分类，不一一列举。</p></blockquote><h1 id="5、总结与思考"><a href="#5、总结与思考" class="headerlink" title="5、总结与思考"></a>5、总结与思考</h1><ul><li><p>亮点：FlowPic的图生成很好，模型分类快，能进行在线分类，不依赖于双向流信息</p><blockquote><p>只考虑时间特征，可以结合空间特征，构造常规的有效载荷流量图，然后进行结合着进行分类？</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;利用了流中与&lt;strong&gt;时间&lt;/strong&gt;相关和与大小相关的特性，将基本流量数据转换为直观的
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文10: Global-Aware Prototypical Network for Few-Shot Encrypted Traffic Classification</title>
    <link href="https://lulu-cloud.github.io/2022/11/11/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%8710%EF%BC%9AGlobal-Aware%20Prototypical%20Network%20for%20Few-Shot%20Encrypted%20Traffic%20Classification/"/>
    <id>https://lulu-cloud.github.io/2022/11/11/加密流量分类-论文10：Global-Aware Prototypical Network for Few-Shot Encrypted Traffic Classification/</id>
    <published>2022-11-11T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:51.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><ul><li><p>现在大部分对于小样本学习的方法都是基于度量(metric learning)解决，但是这些方法只考虑到了流量的局部信息，故对最终的分类性能有一定影响</p></li><li><p>本文提出的GP-Net，<strong>考虑负载序列的两个字节之间的关系，利用字节之中的关系聚合流量输入的全局信息</strong></p></li></ul><blockquote><p>少样本学习是元学习的在监督学习领域的应用，可以参考<a href="[Few-shot learning（少样本学习）入门 - 知乎 (zhihu.com">link</a>](<a href="https://zhuanlan.zhihu.com/p/156830039">https://zhuanlan.zhihu.com/p/156830039</a>))</p></blockquote><h1 id="1、概念介绍"><a href="#1、概念介绍" class="headerlink" title="1、概念介绍"></a>1、概念介绍</h1><h2 id="1-1-基于metric的少样本学习的方法"><a href="#1-1-基于metric的少样本学习的方法" class="headerlink" title="1.1 基于metric的少样本学习的方法"></a>1.1 基于metric的少样本学习的方法</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242125077.png" alt="img"></p><ul><li>过去使用一维卷积神经网络作为编码器解码器提取流量特征的方法，如<a href="[加密流量分类-论文6：Learning to Classify A Flow-Based Relation Network for Encrypted Traffic Classification_烟玉蓝田的博客-CSDN博客](https://blog.csdn.net/qq_45125356/article/details/127142284?spm=1001.2014.3001.5502">RBRN</a>)因为卷积核大小的限制，难以提取整个流量的<strong>全局信息</strong>，因此导致后续计算相似度时，不够精确。</li></ul><h2 id="1-4-文章核心观点引入"><a href="#1-4-文章核心观点引入" class="headerlink" title="1.4 文章核心观点引入"></a>1.4 文章核心观点引入</h2><ul><li><p>论文模型优势：在新流量类型样本不足的情况下学习更好的表示方法</p></li><li><p>四大模块：</p><ul><li><p>流量归一化：将原始流量（输入是流量的有效载荷信息）转为图片</p></li><li><p>全局感知表示：基于自注意力的思想，<strong>并且对负载序列中字节位置信息进行建模</strong>，克服自注意力机制中的位置不可知的缺陷，这样就能聚合流量的全局信息. </p><blockquote><p>所谓全局感知，其实就是引入了自注意力机制而已</p></blockquote></li><li><p>嵌入生成器：卷积操作，因为前面的全局感知，使得这里的卷积不同于以前论文方法的卷积，<font color="red">全局而不局限</font></p></li><li><p>计算相似度模块：与以前方法类似。</p><blockquote><p>通篇下来就是<font color="red">全局</font>两个字</p></blockquote></li></ul><h1 id="2、初步知识"><a href="#2、初步知识" class="headerlink" title="2、初步知识"></a>2、初步知识</h1><h2 id="2-1-元学习概念"><a href="#2-1-元学习概念" class="headerlink" title="2.1 元学习概念"></a>2.1 元学习概念</h2></li></ul><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242125678.png" alt="img"></p><p>&emsp;&emsp;元学习概念：与传统的机器学习不同，元学习的基本单元是一个任务而不是一个训练示例。元学习的主要目标是从元训练任务中获取通用的元知识，并将其用于只需少量样本的元测试任务的快速学习。如上图：训练任务与测试任务是不相关的，用不同颜色与形状表示出来，元学习期待从完成元任务中学习到的知识能很好地迁移到待试验数据上。</p><h2 id="2-2-问题定义"><a href="#2-2-问题定义" class="headerlink" title="2.2 问题定义"></a>2.2 问题定义</h2><p>&emsp;&emsp;假定两个流量数据集，都是有标签的，定义为：</p><script type="math/tex; mode=display">D^{tr}=\{(x_1^{tr},y_1^{tr}),(x_1^{tr},y_1^{tr}),···，(x_K^{tr},y_K^{tr}),\}</script><script type="math/tex; mode=display">其中，x_i^{tr}∈R^d，y_i^{tr}∈\{1,2,···，C\}</script><script type="math/tex; mode=display">D^{test}=\{(x_1^{test},y_1^{tr}),(x_1^{test},y_1^{test}),···，(x_K^{test},y_K^{test}),\}</script><script type="math/tex; mode=display">其中，x_i^{test}∈R^d，y_i^{tr}∈\{C+1,···,C+N\}</script><p>&emsp;&emsp;意味着D<sup>tr</sup>中有C个类别的流量，并且每一种类的流量都有一定的样本，但是，在D<sup>test</sup>中，样本数量非常少，并且类别都是D<sup>tr</sup>中没有的。</p><p>&emsp;&emsp;将训练集与测试集中的任务定义为：</p><script type="math/tex; mode=display">\tau=\{\tau_A^{tr},\tau_B^{tr},\tau_C^{tr},···\}</script><p>每一个元素代表一个任务，是二元分类，如上图，都由支持集(support set)与查询集(query set)组成，叫法这么叫而已，其实就是训练集与验证集。</p><p>&emsp;&emsp;支持集与查询集的形成遵循N-way、K-shot原则，即N个流量类型，每个类型抽k个样本。这样在测试任务中，即使测试任务的支持集很小，但是在元学习的表现下，仍然有不错的泛化性。</p><h1 id="3-GP-Net"><a href="#3-GP-Net" class="headerlink" title="3 GP-Net"></a>3 GP-Net</h1><h2 id="3-1-概览"><a href="#3-1-概览" class="headerlink" title="3.1 概览"></a>3.1 概览</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242125616.png" alt="img"></p><h2 id="3-2-流量归一化模块"><a href="#3-2-流量归一化模块" class="headerlink" title="3.2 流量归一化模块"></a>3.2 流量归一化模块</h2><p>&emsp;&emsp;经典三大步：分流、地址匿名、转为图片形式</p><ul><li><p>分流：这里没说是单向流还是双向会话流，使用工具SplitCap</p></li><li><p>地址匿名：MAC、与IP地址匿名化</p></li><li><p>转图片：取载荷前784（28*28）字节，超则截，短则填</p></li></ul><h2 id="3-3-全局感知模块（Global-aware-representation）"><a href="#3-3-全局感知模块（Global-aware-representation）" class="headerlink" title="3.3 全局感知模块（Global-aware representation）"></a>3.3 全局感知模块（Global-aware representation）</h2><p>&emsp;&emsp;对整个流量输入信息进行聚合,并且引入相对位置机制对字节的位置信息进行建模。</p><h3 id="3-3-1-全局信息增强"><a href="#3-3-1-全局信息增强" class="headerlink" title="3.3.1 全局信息增强"></a>3.3.1 全局信息增强</h3><p>&emsp;&emsp;基于CNN的方法由于卷积核的大小关系，无法捕获有效载荷字节之间远程关系，堆叠CNN后，会造成参数多、存在过拟合的问题，这在少样本的情况下尤为明显。</p><p>&emsp;&emsp;而注意力机制不会，无视空间距离，考虑每一个载荷之间的相互关系。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242125835.png" alt="img"></p><p>对于一个流量图片X，将其拉直，经过运算得到特征向量A：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242135669.png" alt="image-20231124213554439"></p><h3 id="3-3-2-相对位置机制"><a href="#3-3-2-相对位置机制" class="headerlink" title="3.3.2 相对位置机制"></a>3.3.2 相对位置机制</h3><p>&emsp;&emsp;但是，上式子中，自注意机制是位置不可知的。此属性丢失了字节的位置信息，导致流量表示不全面。于是改进，加入相对位置，A表示如下：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242137104.png" alt="image-20231124213721617"></p><p>P<sup>rel</sup>是相对位置矩阵，比如第i与第j个字节的相对位置可以表示如下：</p><script type="math/tex; mode=display">P^{rel}[i,j]=q_ir_{j-i}</script><p>其中q<sub>i</sub>是字节i 的查询向量，r<sub>j-i</sub>是字节i和字节j之间的相对位置嵌入。</p><h3 id="3-3-3-全局增强的特征提取器（Global-enhanced-feature-extractor）"><a href="#3-3-3-全局增强的特征提取器（Global-enhanced-feature-extractor）" class="headerlink" title="3.3.3 全局增强的特征提取器（Global-enhanced feature extractor）"></a>3.3.3 全局增强的特征提取器（Global-enhanced feature extractor）</h3><p>&emsp;&emsp;通过多头注意力机制后，将不同子空间的特征向量进行拼接,得到MA：</p><script type="math/tex; mode=display">MA=Concat[A_1,A_2,···,A_N]W_O</script><p>然后这里还和原始图片X做卷积的结果进行再次拼接，得到输出O:</p><script type="math/tex; mode=display">O=Concat[MA,Conv(X)]</script><blockquote><p>自注意力机制+卷积结果拼接作为输出，考虑了载荷之间的距离信息。</p></blockquote><h2 id="3-4-嵌入生成器"><a href="#3-4-嵌入生成器" class="headerlink" title="3.4 嵌入生成器"></a>3.4 嵌入生成器</h2><p>&emsp;&emsp;这里是四个相同的卷积块进行堆叠，每个都是3*3的卷积核大小，64通道+BN+ReLu+MaxPooling，得到嵌入向量e：</p><script type="math/tex; mode=display">e=f_{\phi}(O)</script><h2 id="3-5-相似度核（Similarity-Kernel）"><a href="#3-5-相似度核（Similarity-Kernel）" class="headerlink" title="3.5 相似度核（Similarity Kernel）"></a>3.5 相似度核（Similarity Kernel）</h2><p>&emsp;&emsp;每一个查询样本x<sup>q</sup>转为嵌入向量e<sup>q</sup>后，与支持集中的每个类型c<sup>i</sup>进行比较，得出相似度进行分类。c<sup>i</sup>是每个i类型的样本嵌入向量评价</p><h1 id="4、实验"><a href="#4、实验" class="headerlink" title="4、实验"></a>4、实验</h1><p>这里抛出三个问题：</p><ul><li><p>小样本学习是否生效</p></li><li><p>注意力机制与相对位置信息是否必要</p></li><li><p>GP-Net调参</p></li></ul><p>  数据集：<strong>USTC-TFC2016</strong></p><blockquote><p>只有一个数据集,个人感觉不够</p></blockquote><ol><li><strong>回答问题1：</strong></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242126075.png" alt="img"></p><p>表里的base是在训练查询集的结果，FewShot是在测试查询集的结果。</p><ol><li><strong>回答问题2：</strong></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242126972.png" alt=""></p><p>消融实验表明：</p><p>第一行表示没有全局感知模块与相对位置机制的模型</p><p>第二行表示没有相对位置机制的模型</p><blockquote><p>但是，我这里感觉在3.3.3 全局感知模块中，加了直接的卷积，没有对那里的卷积进行剔除，感觉这里不好，说不定模型的表现都是基于那个由X直接卷积得到的特征图，而非所谓基于全局感知模块的信息。</p></blockquote><ol><li><strong>回答问题3：</strong></li></ol><p>调参，不看了</p><h1 id="5、总结与思考"><a href="#5、总结与思考" class="headerlink" title="5、总结与思考"></a>5、总结与思考</h1><ul><li>亮点：少样本学习、元学习</li><li>模型总体结构： 输入为有效载荷，结构为自注意力（加上相对位置信息）+卷积，而且注意力中并行着卷积，没有做这个的消融实验。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;现在大部分对于小样本学习的方法都是基于度量(metric learning)解决，但是这些方法只考虑到了流
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文9: DarknetSec_ A novel self-attentive deep learning method for darknet traffic</title>
    <link href="https://lulu-cloud.github.io/2022/10/15/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%879%EF%BC%9ADarknetSec_%20A%20novel%20self-attentive%20deep%20learning%20method%20for%20darknet%20traffic...../"/>
    <id>https://lulu-cloud.github.io/2022/10/15/加密流量分类-论文9：DarknetSec_ A novel self-attentive deep learning method for darknet traffic...../</id>
    <published>2022-10-15T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:48.001Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><p>&emsp;&emsp;提出了一种新的基于自注意力机制深度学习方法DarknetSec，用于暗网流量分类和应用识别；利用一维卷积神经网络(1D CNN)和双向长短期记忆网络(Bi- LSTM)从报文的<strong>有效载荷</strong>内容中捕获局部时空特征，集成自注意机制。此外，DarknetSec从有效载荷统计数据中提取侧通道特征，以增强其分类性能。</p><h1 id="1、文章核心观点引入"><a href="#1、文章核心观点引入" class="headerlink" title="1、文章核心观点引入"></a>1、文章核心观点引入</h1><ul><li>关于目前基于深度学习的分类方法的缺陷：没有充分考虑从不同数据位置提取的局部特征之间的全局内在依赖关系和隐藏联系，最终导致分类性能不稳定</li><li>多头自注意模块的输出和自注意嵌入1D CNN和Bi-LSTM网络提取的局部时空特征同时输入到另一个注意模块中，自动捕获不同注意权重的局部时空特征之间的全局内在依赖关系和隐藏联系</li><li><p>用侧通道特征学习模块从有效载荷统计数据中提取特征表示</p><h1 id="2、模型结构"><a href="#2、模型结构" class="headerlink" title="2、模型结构"></a>2、模型结构</h1></li></ul><blockquote><p>感觉文章的创新点就是在模型结构了，三个分支网络提取不同的特征，从全局与局部的角度去提取流量特征。</p></blockquote><h2 id="2-1-模型总览"><a href="#2-1-模型总览" class="headerlink" title="2.1 模型总览"></a>2.1 模型总览</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242123545.png" alt="在这里插入图片描述"></p><h2 id="2-2-预处理层"><a href="#2-2-预处理层" class="headerlink" title="2.2 预处理层"></a>2.2 预处理层</h2><p>&emsp;&emsp;下面解释一下各个输入的预处理步骤，也就是预处理层（最下一层）干的事情。</p><ul><li><p>预处理pcap或者是pcapng文件，将有两个方向相同的五元组的一组数据包作为流（相当于双向流：会话），<strong>在提取五元组网络流时，我们去掉包头，只保留每个包的应用层数据。</strong></p><blockquote><ul><li>网络层和传输层的协议字段是数据包的基本组成部分，但它们主要是为了网络传输而设计的，而不是为了识别应用程序，故可以剔除</li><li>应用层以下的协议字段包含的有效信息很少，不能为细粒度流分类提供充分的区分特征。</li></ul></blockquote></li><li><p><strong>Content features:</strong>简言之，提取流前N个packet的前M个字节，长则截断，短则填充0</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242123968.png" alt=""></p></li></ul><p>x<sub>content</sub>表示一个样本流的内容特征，所有字节值处于0xff，映射到[0,1]</p><ul><li><strong>Side-channel features：</strong>由统计（statistical）特征与序列特征（sequential）组成<ul><li>选择<strong>流前L个包的长度序列</strong>作为序列特征</li><li>统计特征则有很多，如<ol><li>流持续时间</li><li>数据包之间的时间间隔（最大值、最小值、平均值、标准差、中位数等等）</li><li>包长度统计信息（最大值、最小值、平均值、标准差、中位数等等）</li><li>接受包统计信息（最大值、最小值、平均值、标准差、中位数等等）</li><li>发送包统计信息（最大值、最小值、平均值、标准差、中位数等等）</li><li>入包出包数、字节数、每秒出（入）包比</li></ol></li></ul></li></ul><h2 id="2-4-特征提取层"><a href="#2-4-特征提取层" class="headerlink" title="2.4 特征提取层"></a>2.4 特征提取层</h2><ul><li><p><strong>Side-channel features</strong>送入MLP进行处理</p></li><li><p><strong>Content feature</strong>复制成两份，一份送入多头注意力模块提取全局特征，一份送入局部时空特征学习模块，提取局部的时空关联。由1维卷积与Bi-LSTM组成。最后两个模块的输出进行基于注意力内容的融合（从全局角度获取网络流不同数据位置之间的内在依赖关系，有助于综合内容特征的学习），输出O<sub>acff</sub>：</p></li></ul><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242123186.png" alt="在这里插入图片描述"></p><p>  与上面MLP输出的向量进行拼接后送入分类层</p><h1 id="4、实验"><a href="#4、实验" class="headerlink" title="4、实验"></a>4、实验</h1><ul><li><p>超参数分析：最终敲定N=30，M=256，L=100</p></li><li><p>消融实验：证明各模块有效</p></li></ul><h1 id="5、总结与思考"><a href="#5、总结与思考" class="headerlink" title="5、总结与思考"></a>5、总结与思考</h1><p>&emsp;&emsp;为什么对侧通道特征提取用MLP，对内容特征提取用attention+CNN+LSTM？可不可以做排列组合，这些部件是否有改进或者说舍弃的必要，使得模型具有轻量性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;提出了一种新的基于自注意力机制深度学习方法DarknetSec，用于暗网流量分类和应用识别；利用一维
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文8: An Encrypted Traffic Classification Method Combining Graph Convolutional Network and</title>
    <link href="https://lulu-cloud.github.io/2022/10/13/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%878%EF%BC%9AAn%20Encrypted%20Traffic%20Classification%20Method%20Combining%20Graph%20Convolutional%20Network%20and%20.../"/>
    <id>https://lulu-cloud.github.io/2022/10/13/加密流量分类-论文8：An Encrypted Traffic Classification Method Combining Graph Convolutional Network and .../</id>
    <published>2022-10-13T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:44.932Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><p>&emsp;&emsp;构造了一个k -最近邻(KNN)交通图来表示交通数据的结构，从流量结构和流量数据中学习特征表示，利用两层图卷积网络(GCN)架构进行流特征提取和加密流分类。进一步使用自动编码器学习流数据本身的表示，并将其集成到gcn学习的表示中，利用了GCN和自编码器的优点，在只需要少量标记数据的情况下就能获得较高的分类性能。</p><h1 id="1、文章核心观点引入"><a href="#1、文章核心观点引入" class="headerlink" title="1、文章核心观点引入"></a>1、文章核心观点引入</h1><ul><li><p>样本的结构可以揭示标记样本与未标记样本之间的潜在相似性，为标记样本较少的分类任务提供有价值的指导</p></li><li><p>在网络流量分析领域中，构建流量图来描述流量结构的方法有很多种，但是这些图主要包含了网络的通信模式和拓扑信息，很少包含流量相似度的信息</p></li><li><p>构造k -最近邻图来表示交通数据的结构。我们将交通流作为KNN图中的节点。对每个节点，通过相似度计算找到其前K个相似点作为其近邻，并建立边缘连接。进一步利用图卷积网络(GCN)获取交通结构信息，进行流特征提取和分类</p></li></ul><p>​    如图，相当于两个信息分支：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242121899.png" alt="image-20221013174147808"></p><blockquote><p>关键去找论文如何定义所谓的<strong>相似度</strong></p></blockquote><h1 id="2、模型方法"><a href="#2、模型方法" class="headerlink" title="2、模型方法"></a>2、模型方法</h1><h2 id="2-1-预处理-Data-Preprocessing"><a href="#2-1-预处理-Data-Preprocessing" class="headerlink" title="2.1 预处理(Data Preprocessing)"></a>2.1 预处理(Data Preprocessing)</h2><ul><li><p>流量分割（Traffic Split）:</p><p>&emsp;&emsp;去掉pacp文件头的前24个字节，此24字节只包含pacp文件的统计信息，然后基于5元组分成流（flow）的形式，原始流量就转换成流集合F：</p><script type="math/tex; mode=display">F=[f_1,f_2,...,f_{n}]</script><p>对于每一个f<sub>i</sub>,都包含q个包（packet）</p><script type="math/tex; mode=display">f_i=[p_1^i,p_2^i,...,p_{q}^i]</script></li><li><p>流量过滤（Traffic Purification）:</p><p>&emsp;&emsp;删除每个数据包p中的MAC头，因为它被两个MAC地址填充，也可使它们为零来匿名化这五个元组，并且去掉了所有重复的和空的流文件，避免了对我们分类模型学习能力的不利影响</p></li><li><p>统一长度（Length Unification）:</p><p>&emsp;&emsp;对于大于900字节的流，将其裁剪为900字节，对于小于900字节的流，在流的末尾添加0x00，使其补充为900字节</p></li><li><p>数据归一化（Data Normalization）:</p><p>&emsp;&emsp;将900字节的流序列转换为900维的向量。然后，我们将流向量归一化到范围[0,1]</p></li></ul><p>&emsp;&emsp;经过上述转化，每一个流f<sub>i</sub>都转为流字节向量FBV，原始数据转为矩阵X∈R<sup>N*d</sup>，N代表N个流，d代表一个FBV的维度</p><h2 id="2-2-流量图形构建-Traffic-Graph-Construction"><a href="#2-2-流量图形构建-Traffic-Graph-Construction" class="headerlink" title="2.2 流量图形构建(Traffic Graph Construction)"></a>2.2 流量图形构建(Traffic Graph Construction)</h2><p>&emsp;&emsp;对于流数据X，找到对于每个流最相似的k个流，每个流f作为图的一个节点，找到最相似的流作为相邻的节点，在它们之间设置边。对于两个向量x<sub>i</sub>,x<sub>j</sub>,相似度计算公式如下：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242134374.png" alt="image-20231124213451388"></p><p>其中指数的分子是表示计算两个向量的欧式距离，在计算相似矩阵S后，选取每个流的top-k相似点作为其近邻，构造无向k最近邻图。这里原文给出了一个依据KNN构造图与原始图（trace graph）的差距，通过相似度计算构建KNN流量图，使得相同应用类型的流量之间建立了更多的连接。KNN图比迹图更容易区分不同类型的流量。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242121406.png" alt="image-20221013200300337"></p><h2 id="2-3-分类模型"><a href="#2-3-分类模型" class="headerlink" title="2.3 分类模型"></a>2.3 分类模型</h2><p>&emsp;&emsp;分类模型由GCN与SAE两个部分组成</p><ul><li><p>GCN：将加密的流量分类转换为节点分类任务，考虑两层GCN架构来获取流量结构信息：</p><ul><li><p>第一层GCN的输入：邻接矩阵A和流量数据X。A是图的邻接矩阵，X是原始流量数据的矩阵</p></li><li><p>第一层输出Z<sup>(1)</sup></p><p><img src="https://img-blog.csdnimg.cn/img_convert/40b57138b85db831d173302fc1fbfff2.png" alt="image-20221013200951807"></p><p>其中：</p><script type="math/tex; mode=display">\widehat{A}=A+I</script></li></ul></li></ul><pre><code>D是度数矩阵，D^是对角阵，每个值是A^矩阵的行和，W是权重参数矩阵，外面是激活函数</code></pre><ul><li><p>第二层GCN：</p><p><img src="https://img-blog.csdnimg.cn/img_convert/e0aa71c57af64ea49c1ce2487e64d23b.png" alt="image-20221013201301290"></p><p>损失函数为交叉熵损失。</p></li></ul><ul><li><p>SAE：输入为原始流量X，输出为重构的X，最后一层编码器输出为H<sub>e</sub>，损失函数为均方差MSE损失，故模型总损失为两损失之和。</p><blockquote><p>以上两个部分并没有联结，此处作者的创新将SAE编码器的压缩输出作为辅助信息，与GCN第一层融合，送入GCN第二层，进行分类。由此有如下的Representation Delivery</p></blockquote><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242121047.png" alt="image-20221013203608233"></p></li><li><p><strong>Representation Delivery:</strong>由于KNN流量图是通过相似度计算构造的，因此在KNN图的同一连通分量中，节点的特征更加相似。图卷积运算可能会使它们趋向于收敛于同一值，可能会混合来自不同簇的节点的特征，使它们难以区分，导致过平滑，为了缓解，进行Representation Delivery：</p><script type="math/tex; mode=display">\widetilde{Z}=(1-\phi)Z^{(1)}+\phi H^M_e</script><script type="math/tex; mode=display">\phi是一个平衡参数</script><p>，故GCN输出改为：</p><script type="math/tex; mode=display">Z^{'}=softmax({\widehat{D}}^{-1/2}\widehat{A}\widehat{D}^{-1/2}{\widehat{Z}}^{(1)}W^{(1)})</script><p>这样可以增强节点的特征表示能力，防止GCN过度强调相邻节点的关联而忽略节点本身的特征，从而提高模型分类性能。</p><hr></li></ul><h1 id="4、实验"><a href="#4、实验" class="headerlink" title="4、实验"></a>4、实验</h1><ul><li><p>由于是半监督模型，关于标记率的分析</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242121660.png" alt="image-20221013203925957"></p><p>分析：在所有方法中，随着准确率上升，acc都有增加的趋势，但所提方法的曲线始终高于其他方法，而我们方法的准确率始终优于基线方法。对比结果表明，在低标记率的情况下，将流量结构信息与流量数据相结合进行加密流量分类是有效的。从图中还可以看出，当标记率从10%下降到1%时，我们的方法的准确率下降速度明显慢于其他方法，说明我们的方法具有更好的鲁棒性。</p></li><li><p>超参数分析：</p><p>K与平衡参数\phi</p><p>K取3,5,7比较好</p><p>\phi取0.5比较好</p></li><li><p>似乎没有做消融实验，似乎没有较强说服力说明这个<strong>Representation Delivery</strong>是有效的……</p></li></ul><h1 id="5、总结与思考"><a href="#5、总结与思考" class="headerlink" title="5、总结与思考"></a>5、总结与思考</h1><p>&emsp;&emsp;Representation Delivery的创新，感觉这方面没有做相应的消融实验说不过去，毕竟创新点就是这个，不做消融实验怎么说明它一定是有效的捏。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;构造了一个k -最近邻(KNN)交通图来表示交通数据的结构，从流量结构和流量数据中学习特征表示，利用
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
</feed>
