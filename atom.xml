<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>lulu-cloud</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://lulu-cloud.github.io/"/>
  <updated>2024-05-09T14:25:33.575Z</updated>
  <id>https://lulu-cloud.github.io/</id>
  
  <author>
    <name>luluX</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java八股文查漏补缺-JVM-3-垃圾回收</title>
    <link href="https://lulu-cloud.github.io/2024/05/09/Java%E5%85%AB%E8%82%A1%E6%96%87-JVM3-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    <id>https://lulu-cloud.github.io/2024/05/09/Java八股文-JVM3-垃圾回收/</id>
    <published>2024-05-09T15:46:29.000Z</published>
    <updated>2024-05-09T14:25:33.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>&emsp;&emsp;<strong>Java八股文查漏补缺</strong>系列是针对Java八股复习时，针对在面试时候，问的问题可能比较深入，在<code>JavaGuide</code>网站中的一些八股文可能不够用，根据自己的面试经验进行一些学习补充.</p><p>&emsp;&emsp;八股文背不如理解，理解深刻，知道底层原理，才能更加牢固。呜呜！直接上题</p></blockquote><p>本文目标：完善JVM垃圾回收！</p><h1 id="1-GC只会针对堆吗？"><a href="#1-GC只会针对堆吗？" class="headerlink" title="1. GC只会针对堆吗？"></a>1. GC只会针对堆吗？</h1><p>不是的，还有<strong>方法区</strong>，后面的虚拟机栈GPT可能说的不对，反正GC的区域重点是堆，然后方法区！</p><p><img src="D:\Blog\github\hexo\source\_posts\assets\image-20240422165037815.png" alt="image-20240422165037815"></p><h1 id="2-如何判定一个对象是否可以回收？"><a href="#2-如何判定一个对象是否可以回收？" class="headerlink" title="2. 如何判定一个对象是否可以回收？"></a>2. 如何判定一个对象是否可以回收？</h1><h2 id="2-1-引用计数法"><a href="#2-1-引用计数法" class="headerlink" title="2.1 引用计数法"></a>2.1 引用计数法</h2><p>遇到循环引用，寄</p><h2 id="2-2-可达性分析法（-）"><a href="#2-2-可达性分析法（-）" class="headerlink" title="2.2 可达性分析法（*）"></a>2.2 可达性分析法（*）</h2><p>通过GC Roots的对象作为起始点回收，不可达的都回收掉</p><p>哪些对象可以作为GC Roots对象？</p><ul><li>虚拟机栈中、本地方法栈引用的对象</li><li>方法区中常量引用、类的静态引用的对象</li></ul><h1 id="3-四大引用类型"><a href="#3-四大引用类型" class="headerlink" title="3. 四大引用类型"></a>3. 四大引用类型</h1><ul><li>强引用：new出来的，不会回收</li><li>软引用：内存不够的时候回收</li><li>弱引用：被弱引用关联的对象在下次GC时一定回收</li><li>虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象。为一个对象设置虚引用关联的唯一目的就是能在这个对象被回收时收到一个系统通知。</li></ul><h1 id="4-垃圾回收算法"><a href="#4-垃圾回收算法" class="headerlink" title="4. 垃圾回收算法"></a>4. 垃圾回收算法</h1><ul><li><p>标记-清除：会产生大量内存碎片</p></li><li><p>标记-整理：慢！</p></li><li><p>复制：每次只使用了一半内存，存活的对象复制到另一边上，然后清理当前区域</p><blockquote><p>新生代中，Eden与from是这样的，每次清理Eden与from，剩下存活的复制到to中</p></blockquote></li><li><p>分代：新生代复制，老生代标记-清除或者标记整理</p></li></ul><h1 id="5-垃圾回收器"><a href="#5-垃圾回收器" class="headerlink" title="5. 垃圾回收器"></a>5. 垃圾回收器</h1><h2 id="5-1-CMS收集器"><a href="#5-1-CMS收集器" class="headerlink" title="5.1 CMS收集器"></a>5.1 CMS收集器</h2><p>英文名：Concurrent Mark Sweep 标记-清除，只能对老生代</p><ul><li>目标：最短回收停顿时间</li><li><p>流程：</p><ol><li>初始标记：暂停所有线程，记录与GC roots直接关联的对象，需要停顿</li><li>并发标记：启用所有线程，进行GC roots Trace！耗时最长，无需停顿</li><li>重新标记：修正因为上述线程继续运作的一些标记偏差，需要停顿</li><li>并发清除：无需停顿</li></ol></li><li><p>缺点：</p><ul><li>吞吐量烂</li><li>无法处理浮动垃圾</li><li>有内存碎片</li></ul></li></ul><h2 id="5-2-G1收集器"><a href="#5-2-G1收集器" class="headerlink" title="5.2 G1收集器"></a>5.2 G1收集器</h2><p>英文名Garbage-First，对新生代与老生代通吃！</p><p>G1 把堆划分成多个大小相等的<strong>独立区域(Region)</strong>，新生代和老年代不再物理隔离。</p><ul><li>目标：引入了区域概念，达到了可预测的停顿时间</li><li>流程：<ol><li>初始标记</li><li>并发标记</li><li>最终标记：修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录</li><li>筛选回收：对各个 Region 中的回收价值和成本进行<strong>排序</strong>，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率<ul><li>整体上：标记整理</li><li>局部上：两个Region是复制算法</li></ul></li></ol></li></ul><h1 id="6-内存分配策略"><a href="#6-内存分配策略" class="headerlink" title="6. 内存分配策略"></a>6. 内存分配策略</h1><ol><li><p>对象优先在Eden</p></li><li><p>大对象直接老生代</p></li><li><p>长期存活的放入老生代，有阈值</p></li><li><p>动态判定进入老生代，不一定达到阈值：如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代</p></li><li><p>空间担保机制：在Minor GC时，JVM检查老生代的最大连续可用空间是否大于新生代所有对象空间，</p><ul><li><p>如果成立，发生MinorGC</p></li><li><p>否则，查看查看一个设定的值<code>HandlePromotionFailure</code>是否允许担保失败，如果是</p><ul><li><p>查看老年代最大连续可用空间是否大于历次晋升到老年代对象的评价大，如果是</p><ul><li>尝试MinorGC</li></ul></li></ul></li><li><p>进行Full GC</p></li></ul></li></ol><h1 id="7-GC触发条件"><a href="#7-GC触发条件" class="headerlink" title="7. GC触发条件"></a>7. GC触发条件</h1><ul><li>Minor GC：当Eden满，触发</li><li>Full GC：<ul><li>System.gc()</li><li>老年代空间不足</li><li>空间担保失败</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Java八股文查漏补缺&lt;/strong&gt;系
      
    
    </summary>
    
      <category term="Java学习" scheme="https://lulu-cloud.github.io/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java八股文" scheme="https://lulu-cloud.github.io/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
      <category term="JVM" scheme="https://lulu-cloud.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文查漏补缺-JVM-2-类加载解析</title>
    <link href="https://lulu-cloud.github.io/2024/05/09/Java%E5%85%AB%E8%82%A1%E6%96%87-JVM2-%E7%B1%BB%E5%8A%A0%E8%BD%BD/"/>
    <id>https://lulu-cloud.github.io/2024/05/09/Java八股文-JVM2-类加载/</id>
    <published>2024-05-09T15:16:29.000Z</published>
    <updated>2024-05-09T14:25:39.413Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>&emsp;&emsp;<strong>Java八股文查漏补缺</strong>系列是针对Java八股复习时，针对在面试时候，问的问题可能比较深入，在<code>JavaGuide</code>网站中的一些八股文可能不够用，根据自己的面试经验进行一些学习补充.</p><p>&emsp;&emsp;八股文背不如理解，理解深刻，知道底层原理，才能更加牢固。呜呜！直接上题</p></blockquote><p>本文目标：完善JVM类加载流程！</p><h1 id="1-类生命流程"><a href="#1-类生命流程" class="headerlink" title="1. 类生命流程"></a>1. 类生命流程</h1><ol><li>加载</li><li>验证</li><li>准备</li><li>解析</li><li>初始化</li><li>使用</li><li>卸载</li></ol><p>1 2 3 5按顺序，解析有可能在初始化后面，2 3 4 又称为连接</p><h2 id="1-1-加载"><a href="#1-1-加载" class="headerlink" title="1.1 加载"></a>1.1 加载</h2><p>干三件事！</p><ol><li><strong>全类名-&gt;字节流：</strong>通过类的全名获得它的对应的二进制字节流</li><li><strong>字节流-&gt;方法区运行的数据结构：</strong>字节流所代表的静态存储结构转为方法区中的类的数据结构</li><li><strong>方法区的数据结构-&gt;类的class对象：</strong>在堆中生成该类的class对象，作为对方法区的数据的访问入口</li></ol><h2 id="1-2-连接"><a href="#1-2-连接" class="headerlink" title="1.2 连接"></a>1.2 连接</h2><p><strong>验证：</strong>保证加载符合当前虚拟机要求</p><p><strong>准备：</strong>为<strong>类的静态变量</strong>分配内存并且初始化为<strong>默认值</strong>，而不是程序员所期望的值（初始化才执行）</p><p><strong>解析：</strong>虚拟机的常量池的符合引用替换为直接引用</p><h2 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h2><blockquote><p>为类的静态变量赋予正确的初始值</p></blockquote><h2 id="1-4-使用"><a href="#1-4-使用" class="headerlink" title="1.4 使用"></a>1.4 使用</h2><h2 id="1-5-卸载"><a href="#1-5-卸载" class="headerlink" title="1.5 卸载"></a>1.5 卸载</h2><ul><li>执行了<code>System.exit()</code>方法</li><li>正常介数</li><li>异常或者错误</li><li>os错误</li></ul><h1 id="2-类加载器"><a href="#2-类加载器" class="headerlink" title="2. 类加载器"></a>2. 类加载器</h1><h2 id="2-1-结构"><a href="#2-1-结构" class="headerlink" title="2.1 结构"></a>2.1 结构</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202405092222578.png" alt="image-20240509203211104"></p><p>这里采用的不是继承，是<strong>组合！</strong></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>从JVM角度：</strong>只有启动类加载器（cpp实现）与其他（java实现）</li><li><strong>从开发人员角度：</strong><ul><li>启动类加载器：加载<code>jdk/jre/lib</code>下面，所有以<code>java.*</code>开头的类</li><li>扩展加载器：加载<code>jdk/jre/lib/ext</code>下面，所有以<code>javax.*</code>开头的类</li><li>应用类加载器：加载用户类路径指定的类</li></ul></li></ul><h3 id="加载机制（双亲委派）"><a href="#加载机制（双亲委派）" class="headerlink" title="加载机制（双亲委派）"></a>加载机制（双亲委派）</h3><p><strong>加载类让上级先加载，验证类是否加载自己先验证</strong></p><p>好处：</p><ul><li>类加载层次清晰</li><li>避免类的重复加载</li><li>保证安全</li></ul><p>双亲委派模型保证了 Java 程序的稳定运行，可以<strong>避免类的重复加载</strong>（<strong>JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</strong>），也保证了 Java 的核心 API 不被篡改。</p><h3 id="双亲委派机制的打破"><a href="#双亲委派机制的打破" class="headerlink" title="双亲委派机制的打破"></a>双亲委派机制的打破</h3><p><strong>重写 <code>loadClass()</code>方法</strong>，就可以改变传统双亲委派模型的执行流程。</p><blockquote><p>Tomcat 服务器为了能够优先加载 Web 应用目录下的类，然后再加载其他目录下的类，就自定义了类加载器 <code>WebAppClassLoader</code> 来打破双亲委托机制。这也是 Tomcat 下 Web 应用之间的类实现隔离的具体原理。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Java八股文查漏补缺&lt;/strong&gt;系
      
    
    </summary>
    
      <category term="Java学习" scheme="https://lulu-cloud.github.io/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java八股文" scheme="https://lulu-cloud.github.io/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
      <category term="JVM" scheme="https://lulu-cloud.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文查漏补缺-JVM-1-内存区域模型</title>
    <link href="https://lulu-cloud.github.io/2024/05/09/Java%E5%85%AB%E8%82%A1%E6%96%87-JVM1-%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%A8%A1%E5%9E%8B/"/>
    <id>https://lulu-cloud.github.io/2024/05/09/Java八股文-JVM1-内存区域模型/</id>
    <published>2024-05-09T14:16:29.000Z</published>
    <updated>2024-05-09T14:25:42.571Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>&emsp;&emsp;<strong>Java八股文查漏补缺</strong>系列是针对Java八股复习时，针对在面试时候，问的问题可能比较深入，在<code>JavaGuide</code>网站中的一些八股文可能不够用，根据自己的面试经验进行一些学习补充.</p><p>&emsp;&emsp;八股文背不如理解，理解深刻，知道底层原理，才能更加牢固。呜呜！直接上题</p></blockquote><p>本文目标：完善JVM内存区域状态！</p><h1 id="1-运行时区域"><a href="#1-运行时区域" class="headerlink" title="1. 运行时区域"></a>1. 运行时区域</h1><h2 id="1-1-PC程序计数器"><a href="#1-1-PC程序计数器" class="headerlink" title="1.1 PC程序计数器"></a>1.1 PC程序计数器</h2><h2 id="1-2-虚拟机栈"><a href="#1-2-虚拟机栈" class="headerlink" title="1.2 虚拟机栈"></a>1.2 虚拟机栈</h2><ul><li><p>分配大小：不存在GC问题，分配大小可以动态也可也固定</p></li><li><p>存储单位：<strong>栈帧</strong></p><p>当正常return，栈帧弹出，抛出异常，也会弹出</p><p><strong>内部结构：</strong></p><ol><li>局部变量表：存方法参数与定义在方法的局部变量（基本数据类型与对象<strong>引用</strong>）</li><li>操作数栈：保存计算的中间结构</li><li>动态连接：执行运行时的常量池的方法引用，比如：描述一个方法调用了另外的其他方法时，就是通过常量池中指向方法的符号引用来表示的，那么动态链接的作用就是为了将这些<strong>符号引用转换为调用方法的直接引用</strong></li><li>方法返回地址：存正常返回与异常返回的地址</li><li>附件信息</li></ol></li></ul><h2 id="1-3-本地方法栈"><a href="#1-3-本地方法栈" class="headerlink" title="1.3 本地方法栈"></a>1.3 本地方法栈</h2><h2 id="1-4-堆内存"><a href="#1-4-堆内存" class="headerlink" title="1.4 堆内存"></a>1.4 堆内存</h2><p>逻辑上分代，理由是<strong>优化GC性能</strong></p><p>分代：</p><ul><li><p>新生代：Eden、from、to 8:1:1（Minor GC）</p><ul><li>新创建对象放在Eden区</li><li>Eden满后，执行一次Minor GC，将幸存者放在from或者to中</li><li>多次Minor GC的幸存者放在老年代中</li></ul></li><li><p>老年代：old（Major GC）</p><ul><li>幸存者进入old</li><li>大对象直接进入old</li></ul></li><li><p>元空间：jdk8后直接用物理内存（JVM规范中的<strong>方法区实现</strong>）</p><blockquote><p>如何设置堆大小：</p><ul><li><p><code>Xms</code>：起始内存</p></li><li><p><code>Xmx</code>：最大内存</p><p>一般这两者都一样，省的GC后重新计算堆内存大小</p></li></ul></blockquote></li></ul><h2 id="1-5-方法区（有垃圾回收！）"><a href="#1-5-方法区（有垃圾回收！）" class="headerlink" title="1.5 方法区（有垃圾回收！）"></a>1.5 方法区（有垃圾回收！）</h2><p>方法区？元空间？永久代？什么意思</p><p>永久代、元空间都是方法区的实现！</p><p><strong>jdk8后，没有永久代，只有元空间！元空间的内存是物理内存了而不是像之前一样分配的虚拟机内存</strong></p><p><strong>存储内容：</strong></p><ul><li><p>类的类型信息</p></li><li><p>方法信息</p></li><li><p><strong>运行时的常量池：存放各自字面量与符号引用</strong></p><p>JDK8后字符串常量池、静态变量在堆里了</p></li></ul><h1 id="2-发生OOM的区域"><a href="#2-发生OOM的区域" class="headerlink" title="2. 发生OOM的区域"></a>2. 发生OOM的区域</h1><ol><li>堆：创建了大量对象并且无法被GC回收</li><li>方法区：<strong>方法区用于存储类信息、常量、静态变量等数据</strong>。如果加载的类过多，或者某个类中包含大量的静态变量或常量，就可能导致方法区内存溢出</li><li>栈：用于<strong>存储线程的方法调用栈帧、局部变量和部分运算结果</strong>。如果应用程序中存在<strong>递归调用或者方法调用层级很深</strong>，导致栈帧过多，就会导致栈内存溢出。</li><li>本地方法栈：本地方法栈用于执行本地（Native）方法。如果本地方法调用过程中出现错误，导致本地方法栈溢出，也会触发OOM错误。</li><li>直接内存：直接内存是通过 ByteBuffer.allocateDirect() 方法分配的堆外内存，不受Java堆大小的限制。如果应用程序频繁地创建大量的直接内存对象，但是没有及时释放，就会导致直接内存溢出。（堆外内存需要程序员手动管理，堆外内存可以通过NIO直接访问，不需要进行Java堆到堆外内存的数据拷贝）</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Java八股文查漏补缺&lt;/strong&gt;系
      
    
    </summary>
    
      <category term="Java学习" scheme="https://lulu-cloud.github.io/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java八股文" scheme="https://lulu-cloud.github.io/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
      <category term="JVM" scheme="https://lulu-cloud.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java八股文查漏补缺-Spring-1-AOP 动态代理</title>
    <link href="https://lulu-cloud.github.io/2024/04/13/Java%E5%85%AB%E8%82%A1%E6%96%87-Spring%20AOP/"/>
    <id>https://lulu-cloud.github.io/2024/04/13/Java八股文-Spring AOP/</id>
    <published>2024-04-13T09:27:20.000Z</published>
    <updated>2024-04-14T03:15:59.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>&emsp;&emsp;<strong>Java八股文查漏补缺</strong>系列是针对Java八股复习时，针对在面试时候，问的问题可能比较深入，在<code>JavaGuide</code>网站中的一些八股文可能不够用，根据自己的面试经验进行一些学习补充.</p><p>&emsp;&emsp;八股文背不如理解，理解深刻，知道底层原理，才能更加牢固。呜呜！直接上题</p></blockquote><p>本文目标：完善<code>AOP</code>、<code>动态代理</code>相关内容，<code>AOP</code>有两种，<code>SpringAOP</code>与<code>AspectJAOP</code>，前者基于代理，后者基于字节码</p><h1 id="1-什么情况下AOP会失效？如何解决"><a href="#1-什么情况下AOP会失效？如何解决" class="headerlink" title="1 什么情况下AOP会失效？如何解决"></a>1 什么情况下AOP会失效？如何解决</h1><p>&emsp;&emsp;失效原因有很多，比如没有配置为Bean，切面配置不正确等，但是<strong>最符合的条件就是内部增强方法的相互调用，这样就不会触发AOP，没有走代理</strong></p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202404141114338.png" alt="image-20240412130119799"></p><p>解决方案：</p><ol><li>注入当前代理对象</li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202404141114307.png" alt="image-20240412130302471"></p><ol start="2"><li>暴露当前代理对象到本地线程，然后通过<code>AOPContext.currentProxy()</code>拿到当前正在调用的动态代理对象</li></ol><h1 id="2-两种动态代理详解"><a href="#2-两种动态代理详解" class="headerlink" title="2 两种动态代理详解"></a>2 两种动态代理详解</h1><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202404141114444.png" alt="image-20240412131816267"></p><h4 id="JDK代理："><a href="#JDK代理：" class="headerlink" title="JDK代理："></a>JDK代理：</h4><p>只能代理接口，目标类与代理类都是实现了接口的方法，代理类进行增强，先执行增强方法，然后<strong>通过反射调用目标类方法</strong></p><h4 id="CGLib代理："><a href="#CGLib代理：" class="headerlink" title="CGLib代理："></a>CGLib代理：</h4><p>运行时生成目标类的子类，重写目标类的所有方法，然后进行增强；调用时先通过增强，然后<strong>调用父类的对应方法</strong>，如果类被<code>final</code>修饰，无法代理</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202404141114811.png" alt="image-20240412131531275"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&lt;strong&gt;Java八股文查漏补缺&lt;/strong&gt;系
      
    
    </summary>
    
      <category term="Java学习" scheme="https://lulu-cloud.github.io/categories/Java%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="Java八股文" scheme="https://lulu-cloud.github.io/tags/Java%E5%85%AB%E8%82%A1%E6%96%87/"/>
    
      <category term="Spring" scheme="https://lulu-cloud.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：回溯法1-排列组合问题</title>
    <link href="https://lulu-cloud.github.io/2024/03/13/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%9B%9E%E6%BA%AF%E6%B3%95%EF%BC%88%E4%B8%80%20%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/03/13/力扣刷题-回溯法（一 排列组合）/</id>
    <published>2024-03-13T01:46:20.000Z</published>
    <updated>2024-04-13T09:21:19.827Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-写在前面"><a href="#0-写在前面" class="headerlink" title="0 写在前面"></a>0 写在前面</h1><blockquote><p>回溯法：n叉不等高度数的完全遍历，明确树的下一个分支宽度与树的高度。</p><p>对于宽度：<strong>这个体现在回溯法模板的for循环里面</strong></p><p>对于高度：<strong>体现在回溯法遍历结束的终止条件里面</strong></p><p><strong>这两个的核心思想如下:</strong></p><ol><li><strong>排列问题要搞一个visited数组标记已经访问的</strong></li><li><strong>组合问题要维护好一个起始的索引</strong></li></ol></blockquote><h1 id="1-排列问题-全排列"><a href="#1-排列问题-全排列" class="headerlink" title="1 排列问题 - 全排列"></a>1 排列问题 - 全排列</h1><blockquote><p>LeetCode 46</p><p>给定一个不含重复数字的数组 <code>nums</code> ，返回其 <em>所有可能的全排列</em> 。你可以 <strong>按任意顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：nums = [1,2,3]输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：nums = [0,1]输出：[[0,1],[1,0]]</code></pre><p><strong>示例 3：</strong></p><pre><code>输入：nums = [1]输出：[[1]]</code></pre></blockquote><h2 id="1-1-树的确定"><a href="#1-1-树的确定" class="headerlink" title="1.1 树的确定"></a>1.1 树的确定</h2><ul><li>宽度：每一层都要遍历一下数组的每一个数字，那么树的宽度是nums.length，<strong>这个体现在回溯法模板的for循环里面</strong></li><li>高度：当前的临时list长度为数组长度，结束</li></ul><h2 id="1-2-排列：维护一个visited数组"><a href="#1-2-排列：维护一个visited数组" class="headerlink" title="1.2 排列：维护一个visited数组"></a>1.2 排列：维护一个visited数组</h2><p>回溯时也得同步这个<code>visited</code>数组</p><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;ans,List&lt;Integer&gt;temp,int[]visited,int[]nums)&#123;        if(temp.size()==nums.length)&#123;            ans.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        //回溯法        for(int i = 0;i&lt;nums.length;i++)&#123;            //没有遍历过            if(visited[i]==0)&#123;                temp.add(nums[i]);                visited[i] = 1;                //遍历树的下一层就好                backTrack(ans,temp,visited,nums);                //回溯                temp.remove(temp.size()-1);                visited[i] = 0;            &#125;        &#125;        return ;    &#125;    public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,new int[nums.length],nums);        return res;    &#125;&#125;</code></pre><h1 id="2-组合问题-组合"><a href="#2-组合问题-组合" class="headerlink" title="2 组合问题-组合"></a>2 组合问题-组合</h1><blockquote><p>LeetCode 77</p><p>给定两个整数 <code>n</code> 和 <code>k</code>，返回范围 <code>[1, n]</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>你可以按 <strong>任何顺序</strong> 返回答案。</p><p><strong>示例 1：</strong></p><pre><code>输入：n = 4, k = 2输出：[  [2,4],  [3,4],  [2,3],  [1,2],  [1,3],  [1,4],]</code></pre><p><strong>示例 2：</strong></p><pre><code>输入：n = 1, k = 1输出：[[1]]</code></pre></blockquote><h2 id="2-1-树的确定"><a href="#2-1-树的确定" class="headerlink" title="2.1 树的确定"></a>2.1 树的确定</h2><ul><li><p>索引维护：维护一个<code>index</code>索引，保证当前遍历的起点</p></li><li><p>宽度：当前每次遍历<code>index-n</code>的<code>n-index+1</code>个数</p></li><li>高度：当前临时list长度为k，退出</li></ul><h2 id="2-2-代码"><a href="#2-2-代码" class="headerlink" title="2.2 代码"></a>2.2 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int n,int k,int index)&#123;        if(temp.size()==k)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        //维护一个index，一直往后走        for(int i = index;i&lt;=n;i++)&#123;            temp.add(i);            backTrack(res,temp,n,k,i+1);            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,n,k,1);        return res;    &#125;&#125;</code></pre><h1 id="3-组合总数I"><a href="#3-组合总数I" class="headerlink" title="3 组合总数I"></a>3 组合总数I</h1><blockquote><p>LeetCode39</p></blockquote><h2 id="3-1-树的确定"><a href="#3-1-树的确定" class="headerlink" title="3.1 树的确定"></a>3.1 树的确定</h2><ul><li>高度：不定，如果当前<code>target&lt;0</code>直接返回，<code>target==0</code>，正确返回</li><li>宽度：<code>candidates</code>数组长度</li></ul><h2 id="3-2-代码"><a href="#3-2-代码" class="headerlink" title="3.2 代码"></a>3.2 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int[]candidates,int target,int index)&#123;        //这一步必须，防止为空        if(target&lt;0)&#123;            return ;        &#125;        if(target==0)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        for(int i = index;i&lt;candidates.length;i++)&#123;            target -= candidates[i];            temp.add(candidates[i]);            //可重复的精髓，下一个的起始还是当前            backTrack(res,temp,candidates,target,i);            target += candidates[i];            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        backTrack(res,temp,candidates,target,0);        return res;    &#125;&#125;</code></pre><h1 id="4-组合总数"><a href="#4-组合总数" class="headerlink" title="4 组合总数"></a>4 组合总数</h1><blockquote><p>LeetCode 40</p><p>去重，需要排序后剪枝</p></blockquote><h2 id="4-1-代码"><a href="#4-1-代码" class="headerlink" title="4.1 代码"></a>4.1 代码</h2><pre><code class="lang-java">class Solution &#123;    public void backTrack(List&lt;List&lt;Integer&gt;&gt;res,List&lt;Integer&gt;temp,int[]candidates,int target,int index)&#123;        //这一步必须，防止为空        if(target&lt;0)&#123;            return ;        &#125;        if(target==0)&#123;            res.add(new ArrayList&lt;&gt;(temp));            return ;        &#125;        for(int i = index;i&lt;candidates.length;i++)&#123;            //大剪枝            if(target-candidates[i]&lt;0)&#123;                break;            &#125;            if(i&gt;index&amp;&amp;candidates[i]==candidates[i-1])&#123;                //小剪枝，与前一个元素相等                continue;            &#125;            target -= candidates[i];            temp.add(candidates[i]);            backTrack(res,temp,candidates,target,i+1);            target += candidates[i];            temp.remove(temp.size()-1);        &#125;    &#125;    public List&lt;List&lt;Integer&gt;&gt; combinationSum2(int[] candidates, int target) &#123;        List&lt;List&lt;Integer&gt;&gt;res = new ArrayList&lt;&gt;();        List&lt;Integer&gt;temp = new ArrayList&lt;&gt;();        Arrays.sort(candidates);        backTrack(res,temp,candidates,target,0);        return res;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-写在前面&quot;&gt;&lt;a href=&quot;#0-写在前面&quot; class=&quot;headerlink&quot; title=&quot;0 写在前面&quot;&gt;&lt;/a&gt;0 写在前面&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;回溯法：n叉不等高度数的完全遍历，明确树的下一个分支宽度与树的高度。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：排序</title>
    <link href="https://lulu-cloud.github.io/2024/03/06/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E6%8E%92%E5%BA%8F/"/>
    <id>https://lulu-cloud.github.io/2024/03/06/力扣刷题-排序/</id>
    <published>2024-03-06T01:57:12.000Z</published>
    <updated>2024-04-13T09:21:26.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-堆排序"><a href="#1-堆排序" class="headerlink" title="1 堆排序"></a>1 堆排序</h1><h2 id="1-1-算法流程"><a href="#1-1-算法流程" class="headerlink" title="1.1 算法流程"></a>1.1 算法流程</h2><ol><li><p>从n/2-1处开始构建大根堆（使用堆调整算法）</p></li><li><p>堆顶元素此时为最大值，放入数组末尾，然后重新调整堆</p><blockquote><p>调整堆算法：</p><p>输入：数组arr、堆长度n、根节点位置root</p><ol><li>初始化左右子树与最大值索引变量，左子树为根节点位置*2，右子树为根节点位置*2+1，最大值索引为根节点索引</li><li>最大值索引变量取左右子树的最大值</li><li>如果此时最大值索引已经不是根节点索引<ul><li>交换根节点的值与最大索引值</li><li>递归调整子树</li></ul></li></ol></blockquote></li></ol><h2 id="1-2-代码"><a href="#1-2-代码" class="headerlink" title="1.2 代码"></a>1.2 代码</h2><pre><code class="lang-java">public class HeapSort &#123;    // 主要的堆排序方法    public static void heapSort(int arr[]) &#123;        int n = arr.length;        // 构建最大堆（初始时将数组看作一个完全二叉树）        for (int i = n / 2 - 1; i &gt;= 0; i--) &#123;            heapify(arr, n, i);        &#125;        // 一个一个从堆顶取出元素，将最大值放到数组末尾，然后重新调整堆        for (int i = n - 1; i &gt; 0; i--) &#123;            // 交换堆顶（最大值）和当前未排序部分的最后一个元素            int temp = arr[0];            arr[0] = arr[i];            arr[i] = temp;            // 调整堆，排除刚刚交换的元素            heapify(arr, i, 0);        &#125;    &#125;    // 将子树以root为根的堆调整为最大堆    public static void heapify(int arr[], int n, int root) &#123;        int largest = root; // 初始化根节点为最大值        int leftChild = 2 * root + 1; // 左子节点        int rightChild = 2 * root + 2; // 右子节点        // 如果左子节点比根节点大        if (leftChild &lt; n &amp;&amp; arr[leftChild] &gt; arr[largest]) &#123;            largest = leftChild;        &#125;        // 如果右子节点比根节点或左子节点大        if (rightChild &lt; n &amp;&amp; arr[rightChild] &gt; arr[largest]) &#123;            largest = rightChild;        &#125;        // 如果最大值不是根节点        if (largest != root) &#123;            // 交换根节点和最大值            int temp = arr[root];            arr[root] = arr[largest];            arr[largest] = temp;            // 递归调整受影响的子树            heapify(arr, n, largest);        &#125;    &#125;&#125;</code></pre><h1 id="2-对哈希表的排序"><a href="#2-对哈希表的排序" class="headerlink" title="2 对哈希表的排序"></a>2 对哈希表的排序</h1><pre><code class="lang-java">List&lt;Map.Entry&lt;String, Integer&gt;&gt; sortedEntries = new ArrayList&lt;&gt;(map.entrySet());        Collections.sort(sortedEntries, new Comparator&lt;Map.Entry&lt;String, Integer&gt;&gt;() &#123;            @Override            public int compare(Map.Entry&lt;String, Integer&gt; entry1,                               Map.Entry&lt;String, Integer&gt; entry2) &#123;                // 按照value降序排序                int valueCompare = entry2.getValue().compareTo(entry1.getValue());                if (valueCompare != 0) &#123;                    return valueCompare;                &#125; else &#123;                    // 如果value相同，按照key升序排序                    return entry1.getKey().compareTo(entry2.getKey());                &#125;            &#125;        &#125;);</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-堆排序&quot;&gt;&lt;a href=&quot;#1-堆排序&quot; class=&quot;headerlink&quot; title=&quot;1 堆排序&quot;&gt;&lt;/a&gt;1 堆排序&lt;/h1&gt;&lt;h2 id=&quot;1-1-算法流程&quot;&gt;&lt;a href=&quot;#1-1-算法流程&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析</title>
    <link href="https://lulu-cloud.github.io/2024/03/04/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BBtorch%E5%AE%9E%E8%B7%B53%EF%BC%9ATrafficClassificationPandemonium%E9%A1%B9%E7%9B%AE%E5%88%86%E4%BA%AB/"/>
    <id>https://lulu-cloud.github.io/2024/03/04/加密流量分类torch实践3：TrafficClassificationPandemonium项目分享/</id>
    <published>2024-03-04T09:27:14.000Z</published>
    <updated>2024-03-04T09:49:07.542Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析"><a href="#加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析" class="headerlink" title="加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析"></a>加密流量分类-实践3: TrafficClassificationPandemonium流量分类项目分析</h1><h2 id="1-项目简介"><a href="#1-项目简介" class="headerlink" title="1 项目简介"></a>1 项目简介</h2><p>&emsp;&emsp;该项目是<strong>流量预处理</strong>与<strong>分类验证</strong>的一个统一实现，力求使用清晰的项目结构与最少的代码实现预设功能，目前支持的模型只有<code>1dcnn</code>、<code>app-net</code>两种，后续会进行更新。代码已经开源至<a href="https://github.com/lulu-cloud/TrafficClassificationPandemonium">露露云的github</a>，如果能帮助你，就给鼠鼠点一个star吧！！！</p><h2 id="2-项目使用"><a href="#2-项目使用" class="headerlink" title="2 项目使用"></a>2 项目使用</h2><h3 id="2-1-流量预处理-pcap-gt-npy"><a href="#2-1-流量预处理-pcap-gt-npy" class="headerlink" title="2.1 流量预处理(pcap-&gt;npy)"></a>2.1 流量预处理(pcap-&gt;npy)</h3><blockquote><p>提取网络数据流量的负载、包长序列、统计（当前版本还未实现）的特征，转为<code>npy</code>格式进行持久化存储，基于<code>flowcontainer库</code></p></blockquote><ol><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>preprocess</code>的参数，以下是一个示例</p><pre><code class="lang-yaml">preprocess:  traffic_path: ../traffic_path/android # 原始pcap的路径  datasets: ../datasets/android # 预处理后npy文件的路径  packet_num: 4 # 负载特征参数：流的前4包的负载  byte_num: 256 # 负载特征参数：每个包的前256个字节  ip_length: 128 # 包长特征参数：提取流前128个包长序列  threshold: 4 # 阈值：流包长小于4时舍弃  train_size: 0.8 # 训练集所占比例</code></pre><p>其中对于前<code>packet_num</code>个包的前<code>byte_num</code>字节可以如图说明</p><p><img src="D:\Blog\github\hexo\source\_posts\assets\image-20240304172008854.png" alt="image-20240304172008854"></p><p>负载、包长均作了舍长补短的操作，以达到特定的格式。</p></li><li><p><strong>预处理脚本运行</strong>：</p><p>配置<code>yaml_path</code>即配置文件路径，然后运行代码<code>entry/1_preprocess_with_flowcontainer.py</code></p><pre><code class="lang-py">def main():    yaml_path = r&quot;../configuration/traffic_classification_configuration.yaml&quot;    cfg = setup_config(yaml_path) # 获取 config 文件    pay, seq, label = getPcapIPLength(        cfg.preprocess.traffic_path,        cfg.preprocess.threshold,        cfg.preprocess.ip_length,        cfg.preprocess.packet_num,        cfg.preprocess.byte_num)    split_data(pay,seq,label,cfg.preprocess.train_size,cfg.preprocess.datasets)if __name__==&quot;__main__&quot;:    main()</code></pre></li><li><p><strong>样本字典补齐</strong>：运行完后，得到一个字典输出，将该字典复制到配置文件的<code>test/label2index</code>下</p><pre><code class="lang-yaml">label2index: &#123;&#39;qq&#39;: 0, &#39;微信&#39;: 1, &#39;淘宝&#39;: 2&#125;</code></pre></li></ol><h3 id="2-2-模型训练"><a href="#2-2-模型训练" class="headerlink" title="2.2 模型训练"></a>2.2 模型训练</h3><ol><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>train/test</code>的参数，以下是一个示例</p><p>~~~yaml<br>train:<br>  train_pay: ../TrafficClassificationPandemonium/datasets/android/train/pay_load.npy</p><h1 id="train-seq-npy-data-test-test-ip-length-npy"><a href="#train-seq-npy-data-test-test-ip-length-npy" class="headerlink" title="train_seq: ../npy_data/test/test/ip_length.npy"></a>train_seq: ../npy_data/test/test/ip_length.npy</h1><p>  train_seq: ../TrafficClassificationPandemonium/datasets/android/train/ip_length.npy<br>  train_sta: None<br>  train_label: ../TrafficClassificationPandemonium/datasets/android/train/label.npy<br>  test_pay: ../TrafficClassificationPandemonium/datasets/android/train/pay_load.npy<br>  test_seq: ../TrafficClassificationPandemonium/datasets/android/train/ip_length.npy<br>  test_sta: None<br>  test_label: ../TrafficClassificationPandemonium/datasets/android/train/label.npy<br>  BATCH_SIZE: 128<br>  epochs: 50 # 训练的轮数<br>  lr: 0.001 # learning rate<br>  model_dir: ../TrafficClassificationPandemonium/checkpoint # 模型保存的文件夹</p><h1 id="model-name-cnn1d-pth-模型的名称"><a href="#model-name-cnn1d-pth-模型的名称" class="headerlink" title="model_name: cnn1d.pth # 模型的名称"></a>model_name: cnn1d.pth # 模型的名称</h1><p>  model_name: app-net.pth # 模型的名称</p></li></ol><p>   test:<br>     evaluate: False # 如果是 True, 则不进行训练, 只进行评测<br>     pretrained: False # 是否有训练好的模型# # # {‘Chat’: 0, ‘Email’: 1, ‘FT’: 2, ‘P2P’: 3, ‘Streaming’: 4, ‘VoIP’: 5, ‘VPN_Chat’: 6, ‘VPN_Email’: 7, ‘VPN_FT’: 8, ‘VPN_P2P’: 9, ‘VPN_Streaming’: 10, ‘VPN_VoIP’: 11}<br>     label2index: {‘qq’: 0, ‘微信’: 1, ‘淘宝’: 2}<br>     confusion_path: ../TrafficClassificationPandemonium/result/confusion/ConfusionMatrix-app-net.png<br>   ~~~</p><ol><li><p><strong>运行脚本：</strong>运行代码<code>entry/2_train_test_model.py</code></p><h3 id="2-3-模型测试"><a href="#2-3-模型测试" class="headerlink" title="2.3 模型测试"></a>2.3 模型测试</h3></li><li><p><strong>参数配置</strong>：打开<code>configuration/traffic_classification_configuration.yaml</code>配置文件，配置<code>test</code>的参数的<code>evaluate</code>与<code>pretrained</code>为<code>True</code></p></li><li><p><strong>运行脚本：</strong>运行代码<code>entry/2_train_test_model.py</code></p></li></ol><h3 id="2-4-结果展现"><a href="#2-4-结果展现" class="headerlink" title="2.4 结果展现"></a>2.4 结果展现</h3><ol><li><p>混淆矩阵的展现</p><p>默认在<code>result/confusion</code>下</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745649.png" alt="image-20240304174048201"></p></li><li><p><code>acc</code>、<code>loss</code>曲线的展现</p><p>训练中或者训练后，使用<code>tensorboard --logdir /result/tensorboard</code>进行查看</p></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041746995.png" alt="image-20240304174254396"></p><h2 id="3-项目结构"><a href="#3-项目结构" class="headerlink" title="3 项目结构"></a>3 项目结构</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745638.png" alt="image-20240304173550142"></p><h2 id="4-扩展性"><a href="#4-扩展性" class="headerlink" title="4 扩展性"></a>4 扩展性</h2><ul><li><p><strong>新增模型</strong>：按照<code>models</code>下面的示例进行新增，模型都有两个返回，一个是分类结果，一个是重构结果（框架为了兼容后续上传的模型）</p></li><li><p><strong>切换模型</strong>：在<code>entry/2_train_test_model.py</code>的20/21行进行导入切换即可,下图为一维卷积与appnet的切换示例</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202403041745627.png" alt="image-20240304173853711"></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析&quot;&gt;&lt;a href=&quot;#加密流量分类-实践3-TrafficClassificationPandemonium流量分类项目分析&quot; class=&quot;headerlin
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划3-股票收益系列</title>
    <link href="https://lulu-cloud.github.io/2024/03/03/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%89%20%E8%82%A1%E7%A5%A8%E6%94%B6%E7%9B%8A%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/03/03/力扣刷题-动态规划（三 股票收益）/</id>
    <published>2024-03-03T01:46:20.000Z</published>
    <updated>2024-04-13T09:20:46.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-买卖股票最佳时机"><a href="#1-买卖股票最佳时机" class="headerlink" title="1 买卖股票最佳时机"></a>1 买卖股票最佳时机</h1><blockquote><p>给定一个数组 <code>prices</code> ，它的第 <code>i</code> 个元素 <code>prices[i]</code> 表示一支给定股票第 <code>i</code> 天的价格。</p><p>你只能选择 <strong>某一天</strong> 买入这只股票，并选择在 <strong>未来的某一个不同的日子</strong> 卖出该股票。设计一个算法来计算你所能获取的最大利润。</p><p>返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 <code>0</code> 。</p><p><strong>一次买入卖出</strong></p></blockquote><h2 id="1-1-递归关系"><a href="#1-1-递归关系" class="headerlink" title="1.1 递归关系"></a>1.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日<strong>第一次</strong>入股的成本，<strong>之前没有买过</strong></p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出的股价，<strong>加上昨天手上有股票的收益</strong></li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p></li></ul><h2 id="1-2-边界条件"><a href="#1-2-边界条件" class="headerlink" title="1.2 边界条件"></a>1.2 边界条件</h2><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="2-买卖股票最佳时机II"><a href="#2-买卖股票最佳时机II" class="headerlink" title="2 买卖股票最佳时机II"></a>2 买卖股票最佳时机II</h1><p><strong>与第一题只改动了一行代码！</strong></p><blockquote><p>给你一个整数数组 <code>prices</code> ，其中 <code>prices[i]</code> 表示某支股票第 <code>i</code> 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 <strong>最多</strong> 只能持有 <strong>一股</strong> 股票。你也可以先购买，然后在 <strong>同一天</strong> 出售。</p><p>返回 <em>你能获得的 <strong>最大</strong> 利润</em> 。</p><p><strong>区别：能买入卖出股票很多次！</strong></p></blockquote><h2 id="2-1-递归关系"><a href="#2-1-递归关系" class="headerlink" title="2.1 递归关系"></a>2.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p><strong>今日入股的成本，加上昨天手上无股票的收益</strong></p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出的股价，<strong>加上昨天手上有股票的收益</strong></li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i]+dp[i-1][1])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p><h2 id="2-2-边界条件"><a href="#2-2-边界条件" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],-prices[i]+dp[i-1][1]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="3-买卖股票最佳时机III"><a href="#3-买卖股票最佳时机III" class="headerlink" title="3 买卖股票最佳时机III"></a>3 买卖股票最佳时机III</h1><blockquote><p>给定一个数组，它的第 <code>i</code> 个元素是一支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <strong>两笔</strong> 交易。</p><p><strong>注意：</strong>你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。</p><p><strong>最多买入卖出两次！设置dp[len][4]数组，表示第一次第二次持有与未持有的最大收益</strong></p></blockquote><h2 id="3-1-递归关系"><a href="#3-1-递归关系" class="headerlink" title="3.1 递归关系"></a>3.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp，</p><p>dp[i][0]代表第i天<strong>第一次买卖</strong>手上<strong>有股票</strong>的最大收益，可能是之前买的，也可能是今天第一次买的，</p><p>dp[i][1]代表第i天<strong>第一次买卖</strong>手上<strong>无股票</strong>的最大收益，可能本来就没有买，可能是卖了；</p><p>dp[i][2]代表第i天<strong>第二次买卖</strong>手上<strong>有股票</strong>的最大收益，可能是之前第二次买的，也可能是今天第二次买，</p><p>dp[i][1]代表第i天<strong>第二次买卖</strong>手上<strong>无股票</strong>的最大收益，可能早就卖了第二次，可能是今天卖了；</p><blockquote><p>那么，当前日<strong>第一次有股票</strong>的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p><strong>今日第一次入股</strong></p></li></ol><p>而当前日<strong>第一次无股票</strong>的最大收益：</p><ol><li><p>昨天也无股票的最大收益</p></li><li><p>今日卖出的股价，加上昨天手上有股票的收益</p></li></ol><p>当前日<strong>第二次有股票</strong>的最大收益的两天情况：</p><ol><li>昨天第二次有股票的收益（今天之前就已经买了第二次）</li><li>昨天第一次卖股票的收益-<strong>今天第二次入股的成本</strong>（今天买第二次）</li></ol><p>而当前日<strong>第二次无股票</strong>的最大收益：</p><ol><li>昨天第二次无股票的收益（今天之前就已经卖了第二次）</li><li>昨天第二次有股票的收益+今日股价（今日卖出第二次）</li></ol></blockquote><ul><li><p>当日第一次有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],-price[i])</script></li><li><p>当日第一次无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],price[i]+dp[i-1][0])</script></li><li><p>当日第二次有股票的时候</p><script type="math/tex; mode=display">dp[i][2] = max(dp[i-1][2],dp[i-1][1]-price[i])</script></li><li><p>当日第二次无股票的时候</p><script type="math/tex; mode=display">dp[i][3] = max(dp[i-1][3],dp[i-1][2]+price[i])</script></li></ul><h2 id="3-2-边界条件"><a href="#3-2-边界条件" class="headerlink" title="3.2 边界条件"></a>3.2 边界条件</h2><ul><li><p>第一日<strong>第一次</strong>有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日<strong>第一次</strong>无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li><li><p>第一日<strong>第二次</strong>有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日<strong>第二次</strong>无股票</p><script type="math/tex; mode=display">dp[0][0] = 0</script></li></ul><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        int[][]dp = new int[len][4];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        dp[0][2] = -prices[0];        dp[0][3] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            //第一次有股票            dp[i][0] = Math.max(dp[i-1][0],-prices[i]);            //第一次无股票            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);            //第二次有股票            dp[i][2] = Math.max(dp[i-1][2],dp[i-1][1]-prices[i]);            //第二次无股票            dp[i][3] = Math.max(dp[i-1][3],dp[i-1][2]+prices[i]);        &#125;        return Math.max(Math.max(dp[len-1][0],dp[len-1][1]),Math.max(dp[len-1][2],dp[len-1][3]));    &#125;&#125;</code></pre><h1 id="4-买卖股票最佳时机IV"><a href="#4-买卖股票最佳时机IV" class="headerlink" title="4 买卖股票最佳时机IV"></a>4 买卖股票最佳时机IV</h1><blockquote><p>给你一个整数数组 <code>prices</code> 和一个整数 <code>k</code> ，其中 <code>prices[i]</code> 是某支给定的股票在第 <code>i</code> 天的价格。</p><p>设计一个算法来计算你所能获取的最大利润。你最多可以完成 <code>k</code> 笔交易。也就是说，你最多可以买 <code>k</code> 次，卖 <code>k</code> 次。</p><p><strong>最多可以买卖k次！</strong></p></blockquote><h2 id="4-1-递归关系"><a href="#4-1-递归关系" class="headerlink" title="4.1 递归关系"></a>4.1 递归关系</h2><p>&emsp;&emsp;    设置二维数据dp[len][2k]，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了；dp[i][2]代表第二次买卖手上有股票的最大收益，dp[i][3]代表第二次买卖手上无股票的最大收益；</p><p>……</p><p>递推得知</p><p>dp[i][(k-1)*2]代表第k次买卖手上有股票的最大收益</p><p>dp[i][(k-1)*2+1]代表第k次买卖手上无股票的最大收益</p><ul><li><p>当日有股票的时候</p><ul><li>前一日有股票的最大收益</li><li>前一日无股票的收益-当日入股市的成本<strong>（第一次入股只需成本）</strong><script type="math/tex; mode=display">dp[i][(k-1)*2] = max(dp[i-1][(k-1)*2],-price[i]+if(k-1==0)?0:dp[i-1][(k-1)*2-1])</script></li></ul></li><li><p>当日无股票的时候</p><ul><li>前一个无股票的最大收益</li><li>前一日有股票的最大收益+当日股市的股价</li></ul><script type="math/tex; mode=display">dp[i][(k-1)*2+1] = max(dp[i-1][(k-1)*2+1],dp[i-1][(k-1)*2]+price[i])</script><p><code>price[i]+dp[i-1][0]</code>代表今日卖出，<code>dp[i-1][0]</code>是昨日持有股票的收益，加上今天卖出的价格<code>price[i]</code>才是最终今天卖出的收益</p><h2 id="2-2-边界条件-1"><a href="#2-2-边界条件-1" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li><li><p>第一日有股票(不管买入卖出折腾多少次)</p><script type="math/tex; mode=display">dp[0][(k-1)*2] = -price[0]</script></li><li><p>第一日无股票(不管买入卖出折腾多少次)</p><script type="math/tex; mode=display">dp[0][(k-1)*2+1] = 0</script></li></ul><h2 id="2-3-代码-1"><a href="#2-3-代码-1" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">public class Solution &#123;    public int maxProfit(int k, int[] prices) &#123;        int n = prices.length;        int[][] dp = new int[n][2 * k];        //初始化        for(int index=0;index&lt;2*k;index++)&#123;            if(index%2==0)&#123;                dp[0][index] = -prices[0];            &#125;else&#123;                dp[0][index] = 0;            &#125;        &#125;        for (int i = 1; i &lt; n; i++) &#123;            for (int j = 0; j &lt; k; j++) &#123;                dp[i][j * 2] = Math.max(dp[i - 1][j * 2], -prices[i] + (j != 0 ? dp[i - 1][j * 2 - 1] : 0));                dp[i][j * 2 + 1] = Math.max(dp[i - 1][j * 2 + 1], dp[i - 1][j * 2] + prices[i]);            &#125;        &#125;        int ans = 0;        for(int i=0;i&lt;2*k;i++)&#123;            ans = Math.max(ans,dp[n-1][i]);        &#125;        return ans;    &#125;&#125;</code></pre><h1 id="5-买卖股票含冷冻期"><a href="#5-买卖股票含冷冻期" class="headerlink" title="5 买卖股票含冷冻期"></a>5 买卖股票含冷冻期</h1><h2 id="5-1-递归关系"><a href="#5-1-递归关系" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>与第二题一样，无限制交易次数，但是交易一次后一天内不能再次交易</p></blockquote><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日入股的成本，加上<strong>前天</strong>手上无股票的收益</p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出，加上昨天手上有股票的收益</li></ol></blockquote><ul><li><p>当日有股票的时候</p><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],dp[i-2][1]-price[i])</script></li><li><p>当日无股票的时候</p><script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],dp[i-1][0]+price[i])</script></li><li><h2 id="2-2-边界条件-2"><a href="#2-2-边界条件-2" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2></li></ul><blockquote><p>初始化两天</p></blockquote><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li><li><p>第二日有股票</p><script type="math/tex; mode=display">dp[1][0] = max(dp[0][0],dp[0][1]-price[1])</script></li><li><p>第二日无股票</p><script type="math/tex; mode=display">dp[1][1] = max(dp[0][1],dp[0][0]+price[1])</script></li></ul><h2 id="2-3-代码-2"><a href="#2-3-代码-2" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        if(len&lt;2)&#123;            return 0;        &#125;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        dp[1][0] = Math.max(dp[0][0],dp[0][1]-prices[1]);        dp[1][1] = Math.max(dp[0][1],dp[0][0]+prices[1]);        //开始遍历        for(int i = 2;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],dp[i-2][1]-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre><h1 id="6-买卖股票含手续费"><a href="#6-买卖股票含手续费" class="headerlink" title="6 买卖股票含手续费"></a>6 买卖股票含手续费</h1><h2 id="5-1-递归关系-1"><a href="#5-1-递归关系-1" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>与第二题一样，无限制交易次数，交易一次后要扣钱fee</p></blockquote><p>&emsp;&emsp;    设置二维数据dp，dp[i][0]代表第i天手上有股票的最大收益，可能是之前买的，也可能是今天买的，dp[i][1]代表第i天手上无股票的最大收益，可能本来就没有买，可能是卖了。</p><blockquote><p>那么，当前日有股票的最大收益两种情况：</p><ol><li><p>昨天也有股票的最大收益</p></li><li><p>今日入股的成本，加上<strong>昨天</strong>手上无股票的收益</p></li></ol><p>而当前日无股票的最大收益：</p><ol><li>昨天也无股票的最大收益</li><li>今日卖出，加上昨天手上有股票的收益，并且减去<strong>手续费fee</strong></li></ol></blockquote><ul><li>当日有股票的时候</li></ul><script type="math/tex; mode=display">dp[i][0] = max(dp[i-1][0],dp[i-1][1]-price[i])</script><ul><li>当日无股票的时候<script type="math/tex; mode=display">dp[i][1] = max(dp[i-1][1],dp[i-1][0]+price[i]-fee)</script></li></ul><h2 id="2-2-边界条件-3"><a href="#2-2-边界条件-3" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2><blockquote><p>初始化两天</p></blockquote><ul><li><p>第一日有股票</p><script type="math/tex; mode=display">dp[0][0] = -price[0]</script></li><li><p>第一日无股票</p><script type="math/tex; mode=display">dp[0][1] = 0</script></li></ul><h2 id="2-3-代码-3"><a href="#2-3-代码-3" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int maxProfit(int[] prices, int fee) &#123;        if(prices==null||prices.length==0)&#123;            return 0;        &#125;        int len = prices.length;        if(len&lt;2)&#123;            return 0;        &#125;        int[][]dp = new int[len][2];        //初始化        dp[0][0] = -prices[0];        dp[0][1] = 0;        //开始遍历        for(int i = 1;i&lt;len;i++)&#123;            dp[i][0] = Math.max(dp[i-1][0],dp[i-1][1]-prices[i]);            dp[i][1] = Math.max(dp[i-1][1],dp[i-1][0]+prices[i]-fee);        &#125;        return Math.max(dp[len-1][0],dp[len-1][1]);    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;1-买卖股票最佳时机&quot;&gt;&lt;a href=&quot;#1-买卖股票最佳时机&quot; class=&quot;headerlink&quot; title=&quot;1 买卖股票最佳时机&quot;&gt;&lt;/a&gt;1 买卖股票最佳时机&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组 &lt;code&gt;prices&lt;/code
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：二叉树</title>
    <link href="https://lulu-cloud.github.io/2024/02/26/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>https://lulu-cloud.github.io/2024/02/26/力扣刷题-二叉树/</id>
    <published>2024-02-26T01:54:20.000Z</published>
    <updated>2024-04-13T09:21:05.939Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>二叉树的核心是三个dfs与bfs层序遍历</p></blockquote><h2 id=""><a href="#" class="headerlink" title=" "></a> </h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;二叉树的核心是三个dfs与bfs层序遍历&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot; &quot;&gt;&lt;/a&gt; &lt;/h2&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划2-字符串与子序列问题</title>
    <link href="https://lulu-cloud.github.io/2024/02/25/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%BA%8C%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/02/25/力扣刷题-动态规划（二 字符串相关）/</id>
    <published>2024-02-25T01:46:20.000Z</published>
    <updated>2024-04-13T09:20:29.050Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一般关于字符串的都是二维dp</p></blockquote><h1 id="1-最大回文子串"><a href="#1-最大回文子串" class="headerlink" title="1 最大回文子串"></a>1 最大回文子串</h1><h2 id="1-1-递归关系"><a href="#1-1-递归关系" class="headerlink" title="1.1 递归关系"></a>1.1 递归关系</h2><p>&emsp;&emsp;    设置dp[i][j]是以索引i开头索引j结尾的字符串是否为回文串</p><script type="math/tex; mode=display">dp[i][j] = dp[i+1][j-1]\&\&s[i]==s[j]</script><blockquote><p>此种遍历由下到上开始遍历</p></blockquote><h2 id="1-2-边界条件"><a href="#1-2-边界条件" class="headerlink" title="1.2 边界条件"></a>1.2 边界条件</h2><ol><li><p>串长度为1，都是回文串</p><script type="math/tex; mode=display">dp[i][i] = true</script></li><li><p>子串长度为2</p><script type="math/tex; mode=display">dp[i][i+1] = s[i]==s[i+1]</script></li></ol><h2 id="1-3-代码"><a href="#1-3-代码" class="headerlink" title="1.3 代码"></a>1.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public String longestPalindrome(String s) &#123;        //与字符串的一般都是二维        /**        设置dp[i][j]是以索引i开头索引j结尾的字符串是否为回文串        dp[i][j] = dp[i+1][j-1]&amp;&amp;s[i]==s[j]        初始 dp[i][i] = 1, dp[i][i+1] = s[i]==s[i+1]         */        int len = s.length();        boolean[][]dp = new boolean[len][len];        int start = 0;        int end = 0;        //初始化        for(int i = 0;i&lt;len;i++)&#123;            dp[i][i] = true;            start = i;            end = i+1;        &#125;        for(int i = 0;i&lt;len-1;i++)&#123;            dp[i][i+1] = s.charAt(i)==s.charAt(i+1);            if(dp[i][i+1])&#123;                start = i;                end = i+2;            &#125;        &#125;        //从下到上遍历        for(int i = len-3;i&gt;=0;i--)&#123;            for(int j = i+2;j&lt;len;j++)&#123;                dp[i][j] = dp[i+1][j-1]&amp;&amp;s.charAt(i)==s.charAt(j);                if(dp[i][j])&#123;                    if(j+1-i&gt;end-start)&#123;                        start = i;                        end = j+1;                    &#125;                &#125;            &#125;        &#125;        return s.substring(start,end);    &#125;&#125;</code></pre><h1 id="2-最长回文子序列"><a href="#2-最长回文子序列" class="headerlink" title="2 最长回文子序列"></a>2 最长回文子序列</h1><h2 id="2-1-递归关系"><a href="#2-1-递归关系" class="headerlink" title="2.1 递归关系"></a>2.1 递归关系</h2><script type="math/tex; mode=display">s[i]==s[j]?dp[i][j]=dp[i+1][j-1]+2:max(dp[i+1][j],dp[i][j-1])</script><h2 id="2-2-边界条件"><a href="#2-2-边界条件" class="headerlink" title="2.2 边界条件"></a>2.2 边界条件</h2><p>起始的</p><script type="math/tex; mode=display">dp[i][i]=1</script><h2 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int longestPalindromeSubseq(String s) &#123;        int n = s.length();        int[][]dp = new int[n][n];        for(int i =0;i&lt;n;i++)&#123;            dp[i][i] = 1;        &#125;        //倒着遍历        for(int i = n-2;i&gt;=0;i--)&#123;            for(int j = i+1;j&lt;n;j++)&#123;                if(s.charAt(i)==s.charAt(j))&#123;                    dp[i][j] = dp[i+1][j-1]+2;                &#125;else&#123;                    dp[i][j] = Math.max(dp[i+1][j],dp[i][j-1]);                &#125;            &#125;        &#125;        return dp[0][n-1];    &#125;&#125;</code></pre><h1 id="3-单词拆分（一维dp）"><a href="#3-单词拆分（一维dp）" class="headerlink" title="3 单词拆分（一维dp）"></a>3 单词拆分（一维dp）</h1><h2 id="3-1-递归关系"><a href="#3-1-递归关系" class="headerlink" title="3.1 递归关系"></a>3.1 递归关系</h2><p>&emsp;&emsp;首先弄一个集合set，存储字符串列表中的所有字符串，然后开辟一维dp数组，其中<code>dp[i]</code>的意思代表s[0,i-1]的子串是否能被列表集合单词拆分。二维遍历dp数组</p><script type="math/tex; mode=display">dp[i] = dp[j]\&\&set.contans(s.substring(i,j))</script><p>只要遍历中有一次为<code>true</code>立马结束循环</p><h2 id="3-2-边界条件"><a href="#3-2-边界条件" class="headerlink" title="3.2 边界条件"></a>3.2 边界条件</h2><p>&emsp;&emsp;起始的<code>dp[0]</code>为true</p><h2 id="3-3-代码"><a href="#3-3-代码" class="headerlink" title="3.3 代码"></a>3.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;        boolean[]dp = new boolean[s.length()+1];        Set&lt;String&gt;set = new HashSet&lt;&gt;(wordDict);        dp[0] = true;        for(int i = 1;i&lt;s.length()+1;i++)&#123;            for(int j = 0;j&lt;i;j++)&#123;                dp[i] = dp[j]&amp;&amp;set.contains(s.substring(j,i));                if(dp[i]==true)&#123;                    break;                &#125;            &#125;        &#125;        return dp[s.length()];    &#125;&#125;</code></pre><h1 id="4-编辑距离"><a href="#4-编辑距离" class="headerlink" title="4 编辑距离"></a>4 编辑距离</h1><h2 id="4-1-递归关系"><a href="#4-1-递归关系" class="headerlink" title="4.1 递归关系"></a>4.1 递归关系</h2><script type="math/tex; mode=display">dp[i][j] = s[i]==s[j]?:dp[i-1][j-1]:min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1])+1</script><h2 id="4-2-边界条件"><a href="#4-2-边界条件" class="headerlink" title="4.2 边界条件"></a>4.2 边界条件</h2><p>&emsp;&emsp;需要注意的是在申请dp数组的时候多申请一行一列，存放空串，空串到任意串的步数都是任意串的长度</p><h2 id="4-3-代码"><a href="#4-3-代码" class="headerlink" title="4.3 代码"></a>4.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int minDistance(String word1, String word2) &#123;        int m = word1.length();        int n = word2.length();        int[][]dp = new int[m+1][n+1];        //初始化边界        for(int i = 0;i&lt;m+1;i++)&#123;            dp[i][0] = i;        &#125;        for(int i = 0;i&lt;n+1;i++)&#123;            dp[0][i] = i;        &#125;        //递归        for(int i = 1;i&lt;m+1;i++)&#123;            for(int j = 1;j&lt;n+1;j++)&#123;                //注意这里的i-1，j-1                if(word1.charAt(i-1)==word2.charAt(j-1))&#123;                    dp[i][j]=dp[i-1][j-1];                &#125;else&#123;                    dp[i][j] = Math.min(                        Math.min(dp[i-1][j],dp[i][j-1]),                        dp[i-1][j-1])                        +1;                &#125;            &#125;        &#125;        return dp[m][n];    &#125;&#125;</code></pre><h1 id="5-最长递增子序列"><a href="#5-最长递增子序列" class="headerlink" title="5 最长递增子序列"></a>5 最长递增子序列</h1><h2 id="5-1-递归关系"><a href="#5-1-递归关系" class="headerlink" title="5.1 递归关系"></a>5.1 递归关系</h2><blockquote><p>双重循环，dp[i]代表到以nums[i]结尾的最长子序列的长度，设定第二个变量j，j由0-&gt;i，每次如果nums[i]&gt;nums[j]，那么dp[i]刷新为max(dp[j]+1)，最后取dp的最大值</p></blockquote><script type="math/tex; mode=display">dp[i] = nums[i]>nums[j]?max(dp[j])+1:1</script><h2 id="5-2-边界条件"><a href="#5-2-边界条件" class="headerlink" title="5.2 边界条件"></a>5.2 边界条件</h2><blockquote><p>起始初始化所有的dp[i] = 1</p></blockquote><h2 id="5-3-代码"><a href="#5-3-代码" class="headerlink" title="5.3 代码"></a>5.3 代码</h2><pre><code class="lang-java">class Solution &#123;    public int lengthOfLIS(int[] nums) &#123;        int len = nums.length;        int[]dp = new int[len];        Arrays.fill(dp,1);        int ans = 1;        for(int i = 1;i&lt;len;i++)&#123;            for(int j = 0 ;j&lt;i;j++)&#123;                if(nums[i]&gt;nums[j])&#123;                    dp[i] = Math.max(dp[i],dp[j]+1);                    ans = Math.max(ans,dp[i]);                &#125;            &#125;        &#125;        return ans;    &#125;&#125;</code></pre><h2 id="5-4-最长递增子序列的个数"><a href="#5-4-最长递增子序列的个数" class="headerlink" title="5.4 最长递增子序列的个数"></a>5.4 最长递增子序列的个数</h2><blockquote><ol><li>多使用一个cnt数组记录当前nums[i]结尾的最长地址子序列的个数</li><li>如果dp[j]+1&gt;dp[i]，代表当前的最长子序列更新了，那么cnt[i] = cnt[j]，为前一个</li><li>如果dp[j]+1==dp[i]，那么最长子序列的个数又得更新，cnt[i]+=cnt[j]</li><li>最后取dp[i]最大值对应的cnt数值即可</li></ol></blockquote><pre><code class="lang-JAVA">class Solution &#123;    public int findNumberOfLIS(int[] nums) &#123;        int len = nums.length;        int[]dp = new int[len];        int[]cnt = new int[len];        Arrays.fill(dp,1);        Arrays.fill(cnt,1);        int ans = 1;        for(int i = 1;i&lt;len;i++)&#123;            for(int j = 0 ;j&lt;i;j++)&#123;                if(nums[i]&gt;nums[j])&#123;                    if(dp[j]+1&gt;dp[i])&#123;                        //找到了更长的,那边数字不变                        cnt[i] = cnt[j];                    &#125;else if(dp[j]+1==dp[i])&#123;                        //又一样长的，加上                        cnt[i] += cnt[j];                    &#125;                    dp[i] = Math.max(dp[i],dp[j]+1);                &#125;            &#125;            ans = Math.max(ans,dp[i]);        &#125;        //然后找出cnt中为ans的统计        int res = 0;        for(int i = 0;i&lt;len;i++)&#123;            if(dp[i]==ans)&#123;                res += cnt[i];            &#125;        &#125;        return res;    &#125;       &#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;一般关于字符串的都是二维dp&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&quot;1-最大回文子串&quot;&gt;&lt;a href=&quot;#1-最大回文子串&quot; class=&quot;headerlink&quot; title=&quot;1 最大回文子串&quot;&gt;&lt;/a&gt;1 最大回文子串&lt;/h1&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：动态规划1-打家劫舍</title>
    <link href="https://lulu-cloud.github.io/2024/02/22/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%20%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%EF%BC%89/"/>
    <id>https://lulu-cloud.github.io/2024/02/22/力扣刷题-动态规划（一 打家劫舍）/</id>
    <published>2024-02-22T09:02:18.000Z</published>
    <updated>2024-04-13T09:20:59.338Z</updated>
    
    <content type="html"><![CDATA[<h1 id="递推关系"><a href="#递推关系" class="headerlink" title="递推关系"></a>递推关系</h1><p>&emsp;&emsp;设置dp[i]为当前打劫到第i个户的最大收益，那么，当前收益等于<strong>前一个户的最大收益</strong>与<strong>前两个户的最大收益加上当前户的收益</strong>的最大值：</p><script type="math/tex; mode=display">dp[i] = max(dp[i-1],dp[i-2]+nums[i])</script><h1 id="边界条件"><a href="#边界条件" class="headerlink" title="边界条件"></a>边界条件</h1><ol><li>数组长度为0的情况</li><li>数组长度为1的情况</li><li>dp[0]为第一户的收益，dp[1]为前两个户收益的最大值</li></ol><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><pre><code class="lang-java">class Solution &#123;    public int rob(int[] nums) &#123;        if(nums==null||nums.length==0)&#123;            return 0;        &#125;        int len = nums.length;        if(len==1)&#123;            return nums[0];        &#125;        int[]dp = new int[len];        dp[0] = nums[0];        dp[1] = Math.max(dp[0],nums[1]);        for(int i = 2;i&lt;len;i++)&#123;            //当前的dp = max(前一个dp值,前两个dp值+当前值)            dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]);        &#125;        return dp[len-1];    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;递推关系&quot;&gt;&lt;a href=&quot;#递推关系&quot; class=&quot;headerlink&quot; title=&quot;递推关系&quot;&gt;&lt;/a&gt;递推关系&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;设置dp[i]为当前打劫到第i个户的最大收益，那么，当前收益等于&lt;strong&gt;前一个户的最大收益&lt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征</title>
    <link href="https://lulu-cloud.github.io/2023/12/11/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-3%EF%BC%9A%E5%88%A9%E7%94%A8cic-flowmeter%E5%B7%A5%E5%85%B7%E6%8F%90%E5%8F%96%E6%B5%81%E9%87%8F%E7%89%B9%E5%BE%81/"/>
    <id>https://lulu-cloud.github.io/2023/12/11/流量预处理-3：利用cic-flowmeter工具提取流量特征/</id>
    <published>2023-12-11T02:48:14.000Z</published>
    <updated>2023-12-11T02:58:42.868Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征"><a href="#加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征" class="headerlink" title="加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征"></a>加密流量分类-实践5: 利用CIC-FlowMeter工具提取流量特征</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>&emsp;&emsp;许多研究工作基于<code>CIC-FlowMeter</code>工具提取的csv文件的基础上进行的,目前开源的<code>CIC-FlowMeter</code>工具要么使用jdk编译，要么是给出一个exe可执行文件然后使用图形化界面一个一个处理pcap，在处理大量pacp文件很麻烦，如下图。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048240.png" alt="离线处理pcap"></p><h2 id="2-代码"><a href="#2-代码" class="headerlink" title="2 代码"></a>2 代码</h2><p>这里基于给出的exe可执行文件，利用python脚本批量处理pcap转化为csv文件。</p><pre><code class="lang-python">import osdef generate_batch_csv(pcap_dir,csv_dir,cic_path):    &quot;&quot;&quot;批量将pcap转csv&quot;&quot;&quot;    for label in os.listdir(pcap_dir):        label_path = os.path.join(pcap_dir, label)        csv_label_dir = os.path.join(csv_dir,label)        if not os.path.exists(csv_label_dir):            os.makedirs(csv_label_dir)        for pcap in os.listdir(label_path):            pcap_file = os.path.join(label_path,pcap)            print(f&quot;Analyzing &#123;pcap_file&#125;...&quot;)            # 调用cfm.bat脚本对pcap文件进行分析            os.chdir(cic_path)            os.system(f&#39;call cfm.bat &quot;&#123;pcap_file&#125;&quot; &quot;&#123;csv_label_dir&#125;&quot;&#39;)            print(&quot;Done.&quot;)        print(&quot;完成了&#123;&#125;的处理&quot;.format(label))    print(&quot;所有的都处理完成&quot;)def main():    # 设置pcap和csv文件夹路径    pcap_dir = r&quot;xxx&quot;    csv_dir = r&quot;xx&quot;    cic_dir = r&quot;xx&quot;    generate_batch_csv(pcap_dir,csv_dir,cic_dir)if __name__ == &quot;__main__&quot;:    main()</code></pre><h2 id="3-参数解释与执行效果"><a href="#3-参数解释与执行效果" class="headerlink" title="3 参数解释与执行效果"></a>3 参数解释与执行效果</h2><h3 id="3-1-参数解释"><a href="#3-1-参数解释" class="headerlink" title="3.1 参数解释"></a>3.1 参数解释</h3><ul><li><p><code>pcap_dir</code>:是原始pcap所在的目录，底下是各个标签的目录与对应的pcap，具体如下</p><pre><code>---pcap_dir   -- label_0_dir:      --- label_0_pcap_0      --- label_0_pcap_1      --- label_0_pcap_2      ...   -- label_1_dir:      --- label_1_pcap_0      --- label_1_pcap_1      --- label_1_pcap_2      ...  ...  --- lable_n-1_dir:      --- label_n-1_pcap_0      --- label_n-1_pcap_1      --- label_n-1_pcap_2</code></pre></li><li><p><code>csv_dir</code>:是将csv文件存储的文件夹</p></li><li><p><code>cic_dir</code>:是cic工具的<code>bin</code>目录的所在路径</p><blockquote><p>我这里的示例</p><ul><li><p><code>pcap_dir</code>:</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111049512.png" alt="image-20231211104050740"></p></li><li><p><code>csv_dir</code>:</p><p>随意新建一个文件夹</p></li><li><p><code>cic_dir</code>:</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048581.png" alt="image-20231211104333732"></p></li></ul></blockquote></li></ul><h3 id="3-2-执行效果"><a href="#3-2-执行效果" class="headerlink" title="3.2 执行效果"></a>3.2 执行效果</h3><ol><li><p>截图</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048727.png" alt="image-20231211104723276"></p></li><li><p>成果</p></li></ol><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312111048293.png" alt="image-20231211104541121"></p><p> 以<code>iscx-vpn-novpn2016</code>数据集为例，6分钟搞定</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征&quot;&gt;&lt;a href=&quot;#加密流量分类-实践5-利用CIC-FlowMeter工具提取流量特征&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践5: 利用CIC-FlowMe
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>Tor网络构建(1)-obfs4网桥配置</title>
    <link href="https://lulu-cloud.github.io/2023/12/05/tor-%E7%BD%91%E6%A1%A5%E9%85%8D%E7%BD%AE/"/>
    <id>https://lulu-cloud.github.io/2023/12/05/tor-网桥配置/</id>
    <published>2023-12-05T07:45:14.000Z</published>
    <updated>2024-04-13T09:10:29.343Z</updated>
    
    <content type="html"><![CDATA[<h1 id="实验目标"><a href="#实验目标" class="headerlink" title="实验目标"></a>实验目标</h1><blockquote><p> 搭配tor的obfs4网桥，本地tor浏览器使用该网桥访问tor网络</p></blockquote><h1 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h1><ol><li>本地windows客户端需要下载tor浏览器</li><li>准备一台海外vps，能有公网ip进行访问</li></ol><h1 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h1><h2 id="1-网桥vps配置"><a href="#1-网桥vps配置" class="headerlink" title="1 网桥vps配置"></a>1 网桥vps配置</h2><h3 id="安装tor与obfs4"><a href="#安装tor与obfs4" class="headerlink" title="安装tor与obfs4"></a>安装tor与obfs4</h3><pre><code>apt-get install tor -yapt-get install obfs4proxy -y</code></pre><h3 id="安装nyx监控工具"><a href="#安装nyx监控工具" class="headerlink" title="安装nyx监控工具"></a>安装nyx监控工具</h3><pre><code>apt-get install nyx -y</code></pre><h3 id="修改tor配置文件"><a href="#修改tor配置文件" class="headerlink" title="修改tor配置文件"></a>修改tor配置文件</h3><ol><li>使用该命令修改配置文件</li></ol><pre><code>vi /etc/tor/torrc</code></pre><ol><li>按照官网给出的示例demo，修改</li></ol><pre><code>BridgeRelay 1ORPort port1ServerTransportPlugin obfs4 exec /usr/bin/obfs4proxyServerTransportListenAddr obfs4 0.0.0.0:port2ExtORPort autoPublishServerDescriptor 0Nickname yourName</code></pre><blockquote><p>port1与port2都是自定义的，同时修改vps的防火墙将该两个端口打开</p></blockquote><h3 id="重启tor，记录机器指纹与证书"><a href="#重启tor，记录机器指纹与证书" class="headerlink" title="重启tor，记录机器指纹与证书"></a>重启tor，记录机器指纹与证书</h3><p>使用命令重启tor，然后使用nyx工具进行监控</p><pre><code>systemctl restart tor</code></pre><pre><code>nyx</code></pre><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051527105.png" alt="image-20231205151255192"></p><blockquote><ol><li><p>获取指纹</p><pre><code>cat /var/lib/tor/fingerprint</code></pre><p>该字符串其实就是nyx界面的右上角的fingerprint</p><p><img src="D:\Blog\github\hexo\source\_posts\assets\image-20231206092956574.png" alt="image-20231206092956574"></p></li><li><p>获取证书</p><pre><code>cat /var/lib/tor/pt_state/obfs4_bridgeline.txt</code></pre><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528606.png" alt="image-20231205152826903"></p><p><code>Bridge obfs4 &lt;IP ADDRESS&gt;:&lt;PORT&gt; &lt;FINGERPRINT&gt; cert=xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx iat-mode=0</code></p></li></ol></blockquote><h2 id="2-本地客户端配置"><a href="#2-本地客户端配置" class="headerlink" title="2 本地客户端配置"></a>2 本地客户端配置</h2><ol><li><p>手动选择网桥</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528646.png" alt="image-20231205152036696"></p></li><li><p>填入网桥</p><p>根据第一大部分得到的信息，按照如下格式填充网桥字符串</p><p><code>obfs4 你的vps ip地址:port2 指纹 cert=证书 iat-mode=0</code></p></li><li><p>开始上网</p><blockquote><p>在没有科学上网的环境下尝试访问youtube，点左上角的线路可以看到中继转发情况，通过配置的网桥，然后经历一个普通中继与出口中继转发到目的网络。</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528923.png" alt="image-20231205152419619"></p></blockquote></li></ol><blockquote><p>在浏览器同步点击的时候，nyx查看到vps的流量是有突发的上下行流量的</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202312051528493.png" alt="image-20231205152637974"></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;实验目标&quot;&gt;&lt;a href=&quot;#实验目标&quot; class=&quot;headerlink&quot; title=&quot;实验目标&quot;&gt;&lt;/a&gt;实验目标&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt; 搭配tor的obfs4网桥，本地tor浏览器使用该网桥访问tor网络&lt;/p&gt;
&lt;/blockqu
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="Tor" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/Tor/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>学习算法：图算法-拓扑排序</title>
    <link href="https://lulu-cloud.github.io/2023/04/12/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%9B%BE-%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
    <id>https://lulu-cloud.github.io/2023/04/12/力扣刷题-图-拓扑排序/</id>
    <published>2023-04-12T03:27:18.000Z</published>
    <updated>2024-04-13T09:21:56.090Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一-算法流程"><a href="#一-算法流程" class="headerlink" title="一  算法流程"></a>一  算法流程</h1><ol><li><p>计算每一个节点入度</p><blockquote><p>一般是用数组计算即可</p></blockquote></li><li><p>使用邻接表数据结构，构建图</p><blockquote><p>java里面可以申明一个数组,数组元素类型为一个list,每一个数组是一个list的引用,存储该节点所有的邻接节点</p><pre><code class="lang-java">//邻接表,外层是一个数组，每一个数组引用一个list对象，存储该节点所有的邻接节点List&lt;Integer&gt;[]graph = new ArrayList[numCourses];</code></pre></blockquote></li><li><p>进行拓扑排序，采用<code>BFS</code>算法</p><ul><li><p>构建队列，将所有入度为0的节点进队</p></li><li><p>循环（队列非空）</p><ul><li>将上一轮入队的节点出队，并且将他们的邻接节点都入队</li></ul></li></ul></li><li><p>统计出入队的节点总数,如果小于图节点总数,拓扑排序失败,图中有环.否则成功</p></li></ol><h1 id="二-课程表-1-2"><a href="#二-课程表-1-2" class="headerlink" title="二 课程表(1,2)"></a>二 课程表(1,2)</h1><pre><code class="lang-java">class Solution &#123;    public boolean canFinish(int numCourses, int[][] prerequisites) &#123;        // 1 使用数组存储每一个节点的入度        // 2 构建图，使用邻接表的方法        // 3 拓扑排序（广搜）        //  3.1 将入度为0的节点进队          //循环  3.2 如果队列不空          //   3.3 第一个节点出队，将它的邻居入队        // 4 统计出入队的节点数目，如果等于图节点数目，则拓扑排序成功，否则失败        //1 存储度数表        int[]degrees = new int[numCourses];        //2 邻接表,外层是一个数组，每一个数组引用一个list对象，存储该节点所有的邻接节点        List&lt;Integer&gt;[]graph = new ArrayList[numCourses];        for(int i = 0;i&lt;numCourses;i++)&#123;            graph[i] = new ArrayList&lt;&gt;();        &#125;        // 构建表与图        for(int []item:prerequisites)&#123;            int inNode = item[1];            int outNode = item[0];            degrees[outNode]++;            graph[inNode].add(outNode);        &#125;        Queue&lt;Integer&gt;queue = new LinkedList&lt;&gt;();        //3 入度为0的进队        for(int i =0;i&lt;numCourses;i++)&#123;            if(degrees[i]==0)&#123;                queue.add(i);            &#125;        &#125;        //计数        int cnt = 0;        while(!queue.isEmpty())&#123;            int size = queue.size();            for(int j =0 ;j&lt;size;j++)&#123;                cnt++;                int node = queue.poll();                for(int next:graph[node])&#123;                    //找到所有邻居节点                    //入度更新                    degrees[next]--;                    if(degrees[next]==0)&#123;                        //不会存在重复问题：                        //有向图，只会将入度为0的进入队列，只会进入一次                        queue.offer(next);                    &#125;                &#125;            &#125;        &#125;        return cnt==numCourses;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一-算法流程&quot;&gt;&lt;a href=&quot;#一-算法流程&quot; class=&quot;headerlink&quot; title=&quot;一  算法流程&quot;&gt;&lt;/a&gt;一  算法流程&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;计算每一个节点入度&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;一般是用数组计算即可&lt;/p
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：区间问题</title>
    <link href="https://lulu-cloud.github.io/2023/04/04/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E5%8C%BA%E9%97%B4%E9%97%AE%E9%A2%98/"/>
    <id>https://lulu-cloud.github.io/2023/04/04/力扣刷题-区间问题/</id>
    <published>2023-04-04T03:37:54.000Z</published>
    <updated>2024-04-13T09:21:41.177Z</updated>
    
    <content type="html"><![CDATA[<p>对力扣的区间类题目做一个总结！</p><h1 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h1><h2 id="1-算法思想"><a href="#1-算法思想" class="headerlink" title="1 算法思想"></a>1 算法思想</h2><ol><li><p>按照区间起点升序排序</p><pre><code class="lang-java">//按照区间起始位置排序/**        如果v1[0]-v2[0]为正，代表v1与v2交换位置，故这是升序排序        */Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);</code></pre></li></ol><ol><li><p>设定<code>start</code>与<code>end</code>指针，首先初始化为第一个区间的两端值</p><pre><code class="lang-java">int start = intervals[0][0];int end = intervals[0][1];</code></pre></li></ol><ol><li><p>循环遍历，如果当前的<code>end</code>大于下一个区间的起点，那么说明两个区间有交集了，<code>end</code>更新，更新策略为当前<code>end</code>与下一个区间终点的最大值</p><pre><code class="lang-java">List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();for(int i = 1;i&lt;intervals.length;i++)&#123;    if(end&gt;=intervals[i][0])&#123;        end = Math.max(end,intervals[i][1]);    &#125;    else&#123;        ans.add(new int[]&#123;start,end&#125;);        start = intervals[i][0];        end = intervals[i][1];    &#125;&#125;</code></pre></li><li><p>最后一步由于<code>start</code>与<code>end</code>圈区间的未加入最后结果，再次更新一次</p><pre><code class="lang-java">//最后一个区间加一下ans.add(new int[]&#123;start,end&#125;);int[][]res = new int[ans.size()][2];return ans.toArray(res);</code></pre></li></ol><h2 id="2-完整代码"><a href="#2-完整代码" class="headerlink" title="2 完整代码"></a>2 完整代码</h2><pre><code class="lang-java">class Solution &#123;    public int[][] merge(int[][] intervals) &#123;        //0 特殊情况处理        if(intervals.length&lt;=1)&#123;            return intervals;        &#125;        //1 按照区间起始位置排序        /**        如果v1[0]-v2[0]为正，代表v1与v2交换位置，故这是升序排序        */        Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);        //2 设定start end指针        int start = intervals[0][0];        int end = intervals[0][1];        //3 循环算法策略        List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();        for(int i = 1;i&lt;intervals.length;i++)&#123;            if(end&gt;=intervals[i][0])&#123;                end = Math.max(end,intervals[i][1]);            &#125;            else&#123;                ans.add(new int[]&#123;start,end&#125;);                start = intervals[i][0];                end = intervals[i][1];            &#125;        &#125;        //4 最后一个区间加一下        ans.add(new int[]&#123;start,end&#125;);        int[][]res = new int[ans.size()][2];        return ans.toArray(res);    &#125;&#125;</code></pre><h1 id="无重叠区间"><a href="#无重叠区间" class="headerlink" title="无重叠区间"></a>无重叠区间</h1><h2 id="1-算法思想-1"><a href="#1-算法思想-1" class="headerlink" title="1 算法思想"></a>1 算法思想</h2><p>&emsp;&emsp;本质与合并区间没有什么不同，这里是求没有重叠区间的数目，那么在<code>end</code>指针的更新策略不是取最大，而是取最小。</p><p>区别在第<code>3</code>步</p><ol><li>循环遍历，如果当前的<code>end</code>大于下一个区间的起点，那么说明两个区间有交集了，<code>end</code>更新，更新策略为当前<code>end</code>与下一个区间终点的最大值</li></ol><pre><code class="lang-java">List&lt;int[]&gt;ans = new LinkedList&lt;&gt;();for(int i = 1;i&lt;intervals.length;i++)&#123;    //&gt;=号也要变成&gt;,因为区间刚好相“切”是表明不重叠    if(end&gt;intervals[i][0])&#123;        //这里换成min        //当前end大于下一个区间的起点，那么就是说明交叉了        //end更新        end = Math.min(end,intervals[i][1]);        cnt++;    &#125;    else&#123;        end = intervals[i][1];    &#125;&#125;</code></pre><h2 id="2-完整代码-1"><a href="#2-完整代码-1" class="headerlink" title="2 完整代码"></a>2 完整代码</h2><ul><li>start指针没有用，但是写出</li></ul><pre><code class="lang-java">class Solution &#123;    public int eraseOverlapIntervals(int[][] intervals) &#123;        if(intervals.length==1)&#123;            return 0;        &#125;        //按照区间起始位置排序        Arrays.sort(intervals,(v1,v2)-&gt;v1[0]-v2[0]);        //2         int start = intervals[0][0];        int end = intervals[0][1];        int cnt = 0;        for(int i = 1;i&lt;intervals.length;i++)&#123;            if(end&gt;intervals[i][0])&#123;                //当前end大于下一个区间的起点，那么就是说明交叉了                //end更新                end = Math.min(end,intervals[i][1]);                cnt++;            &#125;else&#123;                start = intervals[i][0];                end = intervals[i][1];            &#125;        &#125;        //cnt表示重叠的数目        return cnt;    &#125;&#125;</code></pre><h1 id="戳气球问题"><a href="#戳气球问题" class="headerlink" title="戳气球问题"></a>戳气球问题</h1><blockquote><p>本质是计算无重叠区间问题，不过需要注意的是这里的区间相切，视作区间重叠，故代码的<code>&gt;</code>又得换回<code>&gt;=</code>拿最终的长度减去重叠的数目返回即可</p></blockquote><h2 id="1-完整代码"><a href="#1-完整代码" class="headerlink" title="1 完整代码"></a>1 完整代码</h2><pre><code class="lang-java">class Solution &#123;    public int findMinArrowShots(int[][] points) &#123;        //一样的套路，排序右边界        if(points.length&lt;=1)&#123;            return 1;        &#125;        Arrays.sort(points,(a,b)-&gt;Integer.compare(a[0],b[0]));        //2         int start = points[0][0];        int end = points[0][1];        int cnt = 0;        for(int i = 1;i&lt;points.length;i++)&#123;            if(end&gt;=points[i][0])&#123;                //当前end大于等于下一个区间的起点，那么就是说明交叉了                //end更新                end = Math.min(end,points[i][1]);                cnt++;            &#125;else&#123;                start = points[i][0];                end = points[i][1];            &#125;        &#125;        //cnt表示重叠的数目        return points.length-cnt;    &#125;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对力扣的区间类题目做一个总结！&lt;/p&gt;
&lt;h1 id=&quot;合并区间&quot;&gt;&lt;a href=&quot;#合并区间&quot; class=&quot;headerlink&quot; title=&quot;合并区间&quot;&gt;&lt;/a&gt;合并区间&lt;/h1&gt;&lt;h2 id=&quot;1-算法思想&quot;&gt;&lt;a href=&quot;#1-算法思想&quot; class=&quot;h
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践4: 流量过滤</title>
    <link href="https://lulu-cloud.github.io/2023/04/01/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-2%EF%BC%9A%E8%BF%87%E6%BB%A4/"/>
    <id>https://lulu-cloud.github.io/2023/04/01/流量预处理-2：过滤/</id>
    <published>2023-04-01T13:27:14.000Z</published>
    <updated>2023-11-24T13:56:04.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践4：流量过滤"><a href="#加密流量分类-实践4：流量过滤" class="headerlink" title="加密流量分类-实践4：流量过滤"></a>加密流量分类-实践4：流量过滤</h1><ul><li>炼丹的时候，经常需要过滤无关流量</li><li>论文的通常做法是将dns、icmp、arp、tcp握手报文删除</li><li><p>以下是给出我的代码，用wirshark前后对比pcap有效</p><pre><code class="lang-python">  from scapy.all import *  from scapy.layers.dns import DNS  from scapy.layers.inet import ICMP, TCP  from scapy.layers.l2 import ARP  def remove_pcap_errors(file_path,new_path):      &quot;&quot;&quot;过滤的pcap与新的pcap不冲突&quot;&quot;&quot;      packets = rdpcap(file_path)      dns_cnt = 0      icmp_cnt = 0      arp_cnt = 0      tcp_flags = 0      new_packets = []      for packet in packets:          if packet.haslayer(DNS):              dns_cnt+=1          elif packet.haslayer(ICMP):              icmp_cnt += 1          elif packet.haslayer(TCP) and (packet[TCP].flags.value==0x12 or packet[TCP].flags.value==0x02 or packet[TCP].flags.value==0x11):              tcp_flags+=1          elif packet.haslayer(ARP):              arp_cnt += 1          else:              new_packets.append(packet)      wrpcap(new_path, new_packets)      print(&quot;dns:&#123;&#125;个&quot;.format(dns_cnt))      print(&quot;icmp:&#123;&#125;个&quot;.format(icmp_cnt))      print(&quot;tcp握手:&#123;&#125;个&quot;.format(tcp_flags))      print(&quot;arp包:&#123;&#125;个&quot;.format(arp_cnt))</code></pre></li><li>处理前：<br>-<img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242148352.png" alt="在这里插入图片描述"></li><li>处理后：<br>-<img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242148932.png" alt="在这里插入图片描述"></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践4：流量过滤&quot;&gt;&lt;a href=&quot;#加密流量分类-实践4：流量过滤&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践4：流量过滤&quot;&gt;&lt;/a&gt;加密流量分类-实践4：流量过滤&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;炼丹的时候，经常需要过滤
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践3: 特征提取</title>
    <link href="https://lulu-cloud.github.io/2023/03/11/%E6%B5%81%E9%87%8F%E9%A2%84%E5%A4%84%E7%90%86-1%EF%BC%9A%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96/"/>
    <id>https://lulu-cloud.github.io/2023/03/11/流量预处理-1：特征提取/</id>
    <published>2023-03-11T13:27:14.000Z</published>
    <updated>2023-11-24T13:48:25.664Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类-实践3：特征提取"><a href="#加密流量分类-实践3：特征提取" class="headerlink" title="加密流量分类-实践3：特征提取"></a>加密流量分类-实践3：特征提取</h1><h2 id="1、原因"><a href="#1、原因" class="headerlink" title="1、原因"></a>1、原因</h2><p> 看着博客<a href="[flowcontainer: 基于python3的pcap网络流量特征信息提取库_Icoding_F2014的博客-CSDN博客](https://blog.csdn.net/jmh1996/article/details/107148871">flowcontainer</a>)的感觉很好，但是有如下缺陷：</p><ol><li><p>处理大文件费内存，关于数据集ISCX2016中的FT类型一个pcap动则就是5个多G，吃不消</p></li><li><p>设置extension字段提取tcp与udp有效负载时，对于上述的大文件处理特别慢！！！原因是加载所有数据进入内存，但是实际预处理只需要前几个包的有效载荷数据，造成内存大开销！</p></li><li><p>如果有pcap开始的数据报文不是包含有效载荷的报文，如开始为icmp报文的pcap文件，该库会报错，具体溯源已找到：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242147711.png" alt="image-20230309201640624"></p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242147859.png" alt="image-20230309201731035"></p><pre><code>            if protocol in [&#39;tcp&#39;,&#39;udp&#39;] and ip_layer == False:                flowid = packet[1] if protocol==&#39;tcp&#39; else packet[2]                srcport = packet[7] if protocol==&#39;tcp&#39; else packet[8]                dstport = packet[11] if protocol==&#39;tcp&#39; else packet[12]                payload_length = packet[15] if protocol ==&#39;tcp&#39; else packet[16]            else:                flowid = 0                srcport = 1                dstport = 0                # 这一行是加上的，如果不加上，payload_length就会为初始化，导致result的appeend失败，从而在流生成的函数里造成对空对象的迭代遍历                payload_length = &#39;0&#39;</code></pre><blockquote><p>红色圈圈是加上的代码，加上后就不会出现致命异常</p></blockquote></li><li><p>但是依旧是慢！在处理大文件的pcap特别费劲！等个几个小时才读取完！</p></li><li><p>分流与SplitCap.exe的分流有出入，目前论文主流方法分流是使用SplitCap.exe工具</p></li></ol><h2 id="2、预处理功能"><a href="#2、预处理功能" class="headerlink" title="2、预处理功能"></a>2、预处理功能</h2><p>直接上代码：</p><pre><code>import binasciiimport scapy.all as scapyimport numpy as npdef hex_to_dec(hex_str, target_length):    dec_list = []    for i in range(0, len(hex_str), 2):        dec_list.append(int(hex_str[i:i + 2], 16))    dec_list = pad_or_truncate(dec_list, target_length)    return dec_listdef pad_or_truncate(some_list, target_len):    return some_list[:target_len] + [0] * (target_len - len(some_list))def pad_or_truncate_seq(some_list, target_len):    return some_list[:target_len] + [0] * (target_len - len(some_list))# 获取流的长度、方向、到达时间序列# 一个字节8位，占两个十六进制数字def get_seq_feature(pcap_path, pack_nums=4, byte_nums=128, seq_length=128, throw=3):    &quot;&quot;&quot;    读取分流好的pcap文件，返回它的ip报文长度、到达时间序列与前pack_num个报文的前byte_num字节的负载    &quot;&quot;&quot;    packets = scapy.rdpcap(pcap_path)    ip_lengths = []    ip_arrive_time = []    pay_load = []    pay_index = []    if len(packets) &lt;= throw:        return ip_lengths, ip_arrive_time, pay_load,pay_index    dic = &#123;&#125;    pay_num = 0    for i, packet in enumerate(packets):        # 提取包长序列        if i == 0:            dst = packet.src            src = packet.dst            dic = &#123;dst: -1, src: 1&#125;        dst = packet.dst        ip_length = dic[dst] * len(packet)        ip_lengths.append(ip_length)        # 包到达时间提取        ip_arrive_time.append(float(packet.time))        # 提取负载与负载在流中包的序号        if len(packet.payload.payload) != 0:            if pay_num &lt; pack_nums:                pay = packet.payload.payload                # print(type(pay))                # print(pay)                data = (binascii.hexlify(bytes(pay)))                data = hex_to_dec(data, target_length=byte_nums)                pay_load.extend(data)                pay_index.append(i+1)                pay_num += 1    if len(pay_index)&lt;pack_nums:        # 不足        for i in range(pack_nums-len(pay_index)):            data = hex_to_dec([],byte_nums)            pay_load.extend(data)            pay_index.append(-1)    ip_lengths = pad_or_truncate_seq(ip_lengths, seq_length)    ip_arrive_time = pad_or_truncate_seq(ip_arrive_time, seq_length)    return ip_lengths, ip_arrive_time, pay_load, pay_index</code></pre><ul><li><p>首先输入是预处理分流好的pcap文件，使用SplitCap.exe分流即可</p><ul><li>函数参数解释</li></ul><pre><code>pack_nums：提取前几个包的负载byte_nums：提取包的前几个字节的负载seq_length：提取流的前几个包的长度（正负表示方向）throw：表示流中的包少于多少个不处理</code></pre><ul><li><p>输出：</p><ul><li><p>包长度</p></li><li><p>包到达时间</p></li><li><p>包负载</p></li><li><p>前几个负载包的流中的序号</p></li></ul></li></ul></li></ul><blockquote><p>上述都是短则补0，长则截断</p></blockquote><p>不会有内存不足的问题辣，处理负载也很快，因为不看报头，所以不需要什么匿名ip，mac地址啥的</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类-实践3：特征提取&quot;&gt;&lt;a href=&quot;#加密流量分类-实践3：特征提取&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类-实践3：特征提取&quot;&gt;&lt;/a&gt;加密流量分类-实践3：特征提取&lt;/h1&gt;&lt;h2 id=&quot;1、原因&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-实践2: CNN+LSTM模型训练与测试</title>
    <link href="https://lulu-cloud.github.io/2023/03/09/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BBtorch%E5%AE%9E%E8%B7%B52%EF%BC%9ACNN+LSTM%E6%A8%A1%E5%9E%8B%E8%AE%AD%E7%BB%83%E4%B8%8E%E6%B5%8B%E8%AF%95/"/>
    <id>https://lulu-cloud.github.io/2023/03/09/加密流量分类torch实践2：CNN+LSTM模型训练与测试/</id>
    <published>2023-03-09T13:27:14.000Z</published>
    <updated>2023-11-25T04:08:46.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="加密流量分类torch实践2：CNN-LSTM模型训练与测试"><a href="#加密流量分类torch实践2：CNN-LSTM模型训练与测试" class="headerlink" title="加密流量分类torch实践2：CNN+LSTM模型训练与测试"></a>加密流量分类torch实践2：CNN+LSTM模型训练与测试</h1><ul><li>代码模板参考：<a href="https://github.com/lulu-cloud/Traffic-Classification">CENTIME:A Direct Comprehensive Traffic Features Extraction for Encrypted Traffic Classification</a></li></ul><h2 id="1、原理"><a href="#1、原理" class="headerlink" title="1、原理"></a>1、原理</h2><ul><li>一维卷积处理负载数据，处理流前n个包的前m个字节</li><li>Bi-LSTM处理包长序列，取流前seq_length的长度序列</li><li>模型结构类似于APP-Net<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142143.png" alt=""></li><li><p>模型代码：<br>~~~<br>  “””<br>  cnn处理负载<br>  lstm处理包长序列<br>  “””</p><p>  import torch<br>  import torch.nn as nn</p></li></ul><pre><code>class Cnn_Lstm(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Cnn_Lstm, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.cnn_feature = nn.Sequential(            nn.Conv1d(kernel_size=25, in_channels=1, out_channels=32, stride=1, padding=12),  # (1,1024)-&gt;(32,1024)            nn.BatchNorm1d(32),  # 加上BN的结果            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (32,1024)-&gt;(32,342)            nn.Conv1d(kernel_size=25, in_channels=32, out_channels=64, stride=1, padding=12),  # (32,342)-&gt;(64,342)            nn.BatchNorm1d(64),            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (64,342)-&gt;(64,114)        )        self.cnn_classifier = nn.Sequential(            # 64*114            nn.Flatten(),            nn.Linear(in_features=64*114, out_features=1024), # 784:88*64, 1024:114*64, 4096:456*64        )        self.cnn=nn.Sequential(            self.cnn_feature,            self.cnn_classifier,        )        self.rnn = nn.Sequential(            nn.LSTM(input_size, hidden_size, num_layers, bidirectional=bidirectional, batch_first=True),        )        self.classifier=nn.Sequential(            nn.Linear(in_features=2048,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_payload=self.cnn(x_payload)        x_sequence=self.rnn(x_sequence)        x_sequence=x_sequence[0][:, -1, :]        x=torch.cat((x_payload,x_sequence),1)        x=self.classifier(x)        return xdef cnn_rnn(model_path, pretrained=False, **kwargs):    model = Cnn_Lstm(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return modelclass Cnn(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Cnn, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.cnn_feature = nn.Sequential(            nn.Conv1d(kernel_size=25, in_channels=1, out_channels=32, stride=1, padding=12),  # (1,1024)-&gt;(32,1024)            nn.BatchNorm1d(32),  # 加上BN的结果            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (32,1024)-&gt;(32,342)            nn.Conv1d(kernel_size=25, in_channels=32, out_channels=64, stride=1, padding=12),  # (32,342)-&gt;(64,342)            nn.BatchNorm1d(64),            nn.ReLU(),            nn.MaxPool1d(kernel_size=3, stride=3, padding=1),  # (64,342)-&gt;(64,114)        )        self.cnn_classifier = nn.Sequential(            # 64*114            nn.Flatten(),            nn.Linear(in_features=64*114, out_features=1024), # 784:88*64, 1024:114*64, 4096:456*64        )        self.cnn=nn.Sequential(            self.cnn_feature,            self.cnn_classifier,        )        self.classifier=nn.Sequential(            nn.Linear(in_features=1024,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_payload=self.cnn(x_payload)        x=self.classifier(x_payload)        return x_payloaddef cnn(model_path, pretrained=False, **kwargs):    model = Cnn(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return modelclass Lstm(nn.Module):    def __init__(self,input_size, hidden_size, num_layers,bidirectional,num_classes=12):        super(Lstm, self).__init__()        self.bidirectional = bidirectional        self.hidden_size = hidden_size        self.num_layers = num_layers        self.lstm = nn.LSTM(input_size, hidden_size, num_layers,bidirectional=bidirectional,batch_first=True)        self.fc0 = nn.Linear(hidden_size, num_classes)        self.fc1= nn.Linear(hidden_size*2,num_classes)        self.rnn = nn.Sequential(            nn.LSTM(input_size, hidden_size, num_layers, bidirectional=bidirectional, batch_first=True),        )        self.classifier=nn.Sequential(            nn.Linear(in_features=1024,out_features=num_classes),            # nn.Dropout(p=0.7),            # nn.Linear(in_features=1024,out_features=num_classes)        )    def forward(self, x_payload,x_sequence):        x_sequence=self.rnn(x_sequence)        x_sequence=x_sequence[0][:, -1, :]        x=self.classifier(x_sequence)        return xdef rnn(model_path, pretrained=False, **kwargs):    model = Lstm(**kwargs)    if pretrained:        checkpoint = torch.load(model_path)        model.load_state_dict(checkpoint[&#39;state_dict&#39;])    return model</code></pre><pre><code>## 2、运行- 在自己的环境下修改路径，包括删除``from sequence_payload.xx import xx``下面的``sequence_payload.``- 修改配置文件``entry``下面的``traffic_classification.yaml``的路径，与模型参数，名字  - 训练流程代码</code></pre><p>from utils.helper import AverageMeter, accuracy<br>from TrafficLog.setLog import logger</p><p>def train_process(train_loader, model, criterion, optimizer, epoch, device, print_freq):<br>    “””训练一个 epoch 的流程</p><pre><code>Args:train_loader (dataloader): [description]model ([type]): [description]criterion ([type]): [description]optimizer ([type]): [description]epoch (int): 当前所在的 epochdevice (torch.device): 是否使用 gpuprint_freq ([type]): [description]&quot;&quot;&quot;losses = AverageMeter()  # 在一个 train loader 中的 loss 变化top1 = AverageMeter()  # 记录在一个 train loader 中的 accuracy 变化model.train()  # 切换为训练模型for i, (pcap, seq,target) in enumerate(train_loader):    pcap = pcap.reshape(-1,1,1024)    seq = seq.reshape(-1,64,1)    pcap = pcap.to(device)    seq = seq.to(device)    target = target.to(device)    output = model(pcap,seq)  # 得到模型预测结果    loss = criterion(output, target)  # 计算 loss    prec1 = accuracy(output.data, target)    losses.update(loss.item(), pcap.size(0))    top1.update(prec1[0].item(), pcap.size(0))    optimizer.zero_grad()    loss.backward()    optimizer.step()    if (i+1) % print_freq == 0:        logger.info(&#39;Epoch: [&#123;0&#125;][&#123;1&#125;/&#123;2&#125;], Loss &#123;loss.val:.4f&#125; (&#123;loss.avg:.4f&#125;), Prec@1 &#123;top1.val:.3f&#125; (&#123;top1.avg:.3f&#125;)&#39;.format(        epoch, i, len(train_loader), loss=losses, top1=top1))return losses.val,top1.val</code></pre><pre><code>  - 验证流程代码： - ## 2.1 数据预处理原理：- 使用flowcontainer包提取含有tcp或者udp负载的包，提取负载与ip数据包序列长度&lt;br/&gt;使用：- 将原始pcap文件放在``traffic_data``下  - 格式:</code></pre><pre><code>|---traffic_data  |---bilibili    |--- xx.pcap    |--- xxx.pcap  |---qq    |--- xx.pcap    |--- xxx.pcap  |--- 今日头条    |--- xx.pcap    |--- xxx.pcap</code></pre><p>  ~~~</p><ul><li>运行<code>entry/preprocess.py</code>,完成后复制控制台输出的<strong>label2index</strong>,粘贴到<code>traffic_classification.yaml/test/traffic_classification.yaml</code></li><li>得到处理好的  <code>npy_data</code><h2 id="2-2-训练"><a href="#2-2-训练" class="headerlink" title="2.2 训练"></a>2.2 训练</h2></li><li><p>打开<code>entry/train.py</code>，注释或者取消注释40、41、42行，选择cnn、lstm、cnn+lstm进行训练，记得改配置文件的<code>model_name</code></p></li><li><p>可以打开tensorboard查看loss与acc曲线</p><ul><li>loss:<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142078.png" alt="在这里插入图片描述"></li></ul></li></ul><ul><li>acc:<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142864.png" alt="在这里插入图片描述"></li></ul><pre><code>&gt; 两图为lstm处理序列数据的tensorboard示例</code></pre><h2 id="2-3-测试"><a href="#2-3-测试" class="headerlink" title="2.3 测试"></a>2.3 测试</h2><ul><li>修改<code>traffic_classification.yaml/test/evaluate</code>为True，打开<code>entry/train.py</code>运行，得到评估结果<br>/evaluate<code>为True，打开</code>entry/train.py``运行，得到评估结果<br><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242142556.png" alt="在这里插入图片描述"><br>项目地址：<a href="https://github.com/lulu-cloud/TrafficClassificationTemplate">lulu-cloud</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;加密流量分类torch实践2：CNN-LSTM模型训练与测试&quot;&gt;&lt;a href=&quot;#加密流量分类torch实践2：CNN-LSTM模型训练与测试&quot; class=&quot;headerlink&quot; title=&quot;加密流量分类torch实践2：CNN+LSTM模型训练与测试&quot;&gt;
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="实验" scheme="https://lulu-cloud.github.io/tags/%E5%AE%9E%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>算法学习：二分查找</title>
    <link href="https://lulu-cloud.github.io/2023/03/02/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98-%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>https://lulu-cloud.github.io/2023/03/02/力扣刷题-二分查找/</id>
    <published>2023-03-02T01:27:18.000Z</published>
    <updated>2024-04-13T09:21:12.959Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、-原则"><a href="#一、-原则" class="headerlink" title="一、 原则"></a>一、 原则</h1><h2 id="1-区间：左右闭区间"><a href="#1-区间：左右闭区间" class="headerlink" title="1. 区间：左右闭区间"></a>1. 区间：左右闭区间</h2><h2 id="2-while结束设定为-lt"><a href="#2-while结束设定为-lt" class="headerlink" title="2. while结束设定为&lt;="></a>2. while结束设定为&lt;=</h2><h2 id="3-左右界更新都为mid上下1"><a href="#3-左右界更新都为mid上下1" class="headerlink" title="3. 左右界更新都为mid上下1"></a>3. 左右界更新都为mid上下1</h2><blockquote><ol><li><p>二分查找可以设定左闭右开的写法，也可以左右都是闭区间，这里设定后者</p></li><li><p>在1的设定下，如果left=right，即当前搜索区间长度为1，如果while里面不是&lt;=二是严格&lt;,那么该长度为1的区间就不会搜索，出现遗漏</p></li><li><p>在1，2的设定之下，必须让left、right的更新机制在循环结束后，right在left的左边，即每次更新right与left必须都不能为mid，因为mid可能 在区间长度为1或者2的时候mid等于其中的left，必须使得right与left有机制在更新时不能一直等于mid，故有原则3</p></li></ol></blockquote><h1 id="二、三种情况"><a href="#二、三种情况" class="headerlink" title="二、三种情况"></a>二、三种情况</h1><h2 id="2-1-直接找元素"><a href="#2-1-直接找元素" class="headerlink" title="2.1 直接找元素"></a>2.1 直接找元素</h2><pre><code class="lang-java">int searchBinary(int[] nums, int target) &#123;    //原则1 左右闭区间    int left = 0, right = nums.length - 1;    //原则2 while结束条件为&lt;=    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            return mid;        &#125; else if (nums[mid] &lt; target) &#123;            //原则3 左右界更新为mid加减1            left = mid + 1;        &#125; else &#123;            //原则3 左右界更新为mid加减1            right = mid - 1;        &#125;    &#125;    return -1;&#125;</code></pre><h2 id="2-2-寻找左右边界"><a href="#2-2-寻找左右边界" class="headerlink" title="2.2 寻找左右边界"></a>2.2 寻找左右边界</h2><p>给定有序数组</p><script type="math/tex; mode=display">[0,1,2,2,2,3,4]</script><p>如何找第一个2出现的下标或者最后一个2出现的下标</p><ul><li>找第一个：找左边界</li></ul><pre><code class="lang-java">int searchLeftBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            right = mid - 1; // 收缩右边界        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    // 越界检查，不存在检查    if (left &gt;= nums.length || nums[left] != target) &#123;        return -1;    &#125;    return left;&#125;</code></pre><ul><li>找最后一个：找右边界</li></ul><pre><code class="lang-java">int searchRightBound(int[] nums, int target) &#123;    int left = 0, right = nums.length - 1;    while (left &lt;= right) &#123;        int mid = left + ((right - left) &gt;&gt; 1);        if (nums[mid] == target) &#123;            left = mid + 1; // 收缩左边界        &#125; else if (nums[mid] &lt; target) &#123;            left = mid + 1;        &#125; else &#123;            right = mid - 1;        &#125;    &#125;    if (right &lt; 0 || nums[right] != target) &#123;        return -1;    &#125;    return right;&#125;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;一、-原则&quot;&gt;&lt;a href=&quot;#一、-原则&quot; class=&quot;headerlink&quot; title=&quot;一、 原则&quot;&gt;&lt;/a&gt;一、 原则&lt;/h1&gt;&lt;h2 id=&quot;1-区间：左右闭区间&quot;&gt;&lt;a href=&quot;#1-区间：左右闭区间&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://lulu-cloud.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
      <category term="力扣刷题" scheme="https://lulu-cloud.github.io/tags/%E5%8A%9B%E6%89%A3%E5%88%B7%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>加密流量分类-论文12: Seeing Traffic Paths_ Encrypted Traffic Classification With Path Signature Features</title>
    <link href="https://lulu-cloud.github.io/2023/01/19/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB-%E8%AE%BA%E6%96%8712%EF%BC%9ASeeing%20Traffic%20Paths_%20Encrypted%20Traffic%20Classification%20With%20Path%20Signature%20Features/"/>
    <id>https://lulu-cloud.github.io/2023/01/19/加密流量分类-论文12：Seeing Traffic Paths_ Encrypted Traffic Classification With Path Signature Features/</id>
    <published>2023-01-19T13:27:14.000Z</published>
    <updated>2023-11-24T13:43:57.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0、摘要"><a href="#0、摘要" class="headerlink" title="0、摘要"></a>0、摘要</h1><p>&emsp;&emsp;本文提出了一种新的带路径签名的加密流分类方法——ETC-PS。首先用<strong>会话数据包长度序列</strong>构造<strong>流量路径</strong>来表示客户端和服务器之间的交互。然后进行<strong>路径变换</strong>，展示其结构，获得不同的信息。最后计算出多尺度路径特征作为一种显著特征来训练传统的<strong>机器学习</strong>分类器，实现了高鲁棒精度和低训练开销。</p><h1 id="1、模型方法"><a href="#1、模型方法" class="headerlink" title="1、模型方法"></a>1、模型方法</h1><ul><li><p>将<strong>路径签名</strong>应用与加密流量分类，只使用了流量的序列特征。</p><ol><li>机器学习分类：要走数据预处理、特征工程、分类等过程，相交于深度学习方法多了特征工程</li><li>特征工程：从会话中客户端-服务器双向交互的流量特征构建了流量路径，再进行路径变换，作为分类器输入</li></ol><h2 id="1-1-路径签名定义与科普"><a href="#1-1-路径签名定义与科普" class="headerlink" title="1.1 路径签名定义与科普"></a>1.1 路径签名定义与科普</h2></li></ul><h3 id="1-1-1科普"><a href="#1-1-1科普" class="headerlink" title="1.1.1科普"></a>1.1.1科普</h3><p>参考<a href="[Path Signature笔记 - 知乎 (zhihu.com"><a href="https://zhuanlan.zhihu.com/p/335494125">Path Signature笔记 - 知乎 (zhihu.com)</a></a>](<a href="https://zhuanlan.zhihu.com/p/335494125">https://zhuanlan.zhihu.com/p/335494125</a>))</p><h3 id="1-1-2-路径签名的一些性质"><a href="#1-1-2-路径签名的一些性质" class="headerlink" title="1.1.2 路径签名的一些性质"></a>1.1.2 路径签名的一些性质</h3><ul><li><strong>唯一性</strong>：<strong>由路径签名可以完全确定一个路径，</strong>具有单调维度的路径(如时间)没有支路部分。因此，对于一个加密的流量报文长度序列(一维路径)，通常需要添加一个单调递增的维度(例如时间)，以保证路径签名可以等价地确定它</li><li><strong>重新参数化不变性：</strong> <strong>对于一个路径，采用不同的采样频率得到的路径表示会不同，但是路径签名不会变。</strong>对于特定类型应用程序生成的流量，分类结果应该不受不同重参数化的影响。有了这个特性，签名可以过滤掉同种流量的不同重参数化引起的变化，不会分为不同应用。</li><li><strong>维数固定:</strong> <strong>从整个路径中提取的路径特征的维数取决于截断级别，与路径长度无关。</strong>再短的路径其签名维数也是无限长，使用的时候取决于我们截断的维度是多少。</li></ul><h2 id="1-2-ETC-PS整体预览"><a href="#1-2-ETC-PS整体预览" class="headerlink" title="1.2 ETC-PS整体预览"></a>1.2 ETC-PS整体预览</h2><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242128763.png" alt="image-20230119105316076"></p><ol><li>收集报文序列，计算报文长度，生成报文长度序列，使用正负号表示报文序列的不同方向</li><li>进行路径构造</li><li>进行路径变换</li><li>进行路径签名特征提取得到特征</li><li>使用机器学习分类器进行分类</li></ol><h2 id="1-3-流量路径构造"><a href="#1-3-流量路径构造" class="headerlink" title="1.3 流量路径构造"></a>1.3 流量路径构造</h2><h3 id="1-3-1-客户端与服务器的双向交互"><a href="#1-3-1-客户端与服务器的双向交互" class="headerlink" title="1.3.1 客户端与服务器的双向交互"></a>1.3.1 客户端与服务器的双向交互</h3><p>&emsp;&emsp;当客户端和服务器之间建立连接时，客户端通常会向服务器发送请求，请求服务器发送所需的资源。主要分为3个阶段</p><ul><li><p>握手阶段：上行和下行报文在此阶段交替传输。对于同一种传输协议，在此阶段生成的报文序列非常相似，包括报文长度、数量、方向等。（<strong>有明显特征</strong>）</p></li><li><p>上行报文主导阶段：上行报文（C-&gt;S）主要在此阶段传输。通常将控制指令编码的上行报文发送给服务器，邀请服务器配合提高数据传输效率。</p></li><li><p>下行报文主导阶段：下行报文（S-&gt;C）主要在此阶段传输。下行报文用于传输客户端所需要的内容</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242128673.png" alt="image-20230119105857080"></p></li></ul><h3 id="1-3-2-网络流量路径构建"><a href="#1-3-2-网络流量路径构建" class="headerlink" title="1.3.2 网络流量路径构建"></a>1.3.2 网络流量路径构建</h3><p>&emsp;&emsp;其实就是将流量报文长度序列收集起来，生成原始序列S,即一条一维路径，也就是流量路径X<sub>t</sub><sup>0</sup>其中上标0表示这是原始流量路径。</p><blockquote><p>给出代码提取报文长度序列，（无关原文）使用代码提取ip数据报文长度序列如下</p></blockquote><pre><code>from flowcontainer.extractor import extractpcap_path = r&quot;XX.pcap&quot;result = extract(pcap_path)for i , key in enumerate(result):    print(&quot;flow&#123;&#125;&quot;.format(i))    value = result[key]    print(&#39;ip lengths :&#39;,value.ip_lengths)    print(&#39;\n&#39;)</code></pre><h2 id="1-4-路径转换"><a href="#1-4-路径转换" class="headerlink" title="1.4 路径转换"></a>1.4 路径转换</h2><p>&emsp;&emsp;在大多数情况下，一维流量路径的路径特征往往不够有效，无法达到较高的分类精度。</p><h3 id="1-4-1-路径分解变换"><a href="#1-4-1-路径分解变换" class="headerlink" title="1.4.1 路径分解变换"></a>1.4.1 路径分解变换</h3><ul><li><p>路径分解变换将一条路径转化为相同维数的子路径集合</p><ul><li><p>一维路径X<sub>t</sub><sup>0</sup>首先分解为上行序列路径U<sub>0</sub>与下行序列路径D<sub>0</sub></p></li><li><p>此时变为<strong>二维路径</strong>X<sub>t</sub><sup>0,d</sup>={U,D},上标d表示进行的解体变换，将另一个方向的数据包长度替换为0，即X<sub>t</sub><sup>0，d</sup>中上行序列U的报文长度全替换为0</p></li></ul></li></ul><blockquote><p>变换理由：为了提高路径签名特征的效率，将流量路径转换为两条一维流量路径，这也符合客户端-服务器交互的特点。</p></blockquote><h3 id="1-4-2-累积和变换"><a href="#1-4-2-累积和变换" class="headerlink" title="1.4.2 累积和变换"></a>1.4.2 累积和变换</h3><p>&emsp;&emsp;一般来讲，报文要传输的有效载荷通常是固定的，用于相同的网站或服务，这导致非常相似的累积和特征。</p><p>对于U0序列，累积和可如下表示：</p><script type="math/tex; mode=display">U'=(u_1',u_2',...,u_n'),u_n'=\sum_{i=1}^ku_i</script><p>D0序列类似</p><ul><li>于是变换为<strong>四维</strong>，X<sub>t</sub><sup>0,d,c</sup>={U,D,U’,D’}</li></ul><blockquote><p>变换理由：要传输的有效载荷对于同一网站或服务往往是固定的,使用累积和变换来暴露流量路径的一些内部特征。</p></blockquote><h3 id="1-4-3-基准点变换"><a href="#1-4-3-基准点变换" class="headerlink" title="1.4.3 基准点变换"></a>1.4.3 基准点变换</h3><p>使用函数f</p><script type="math/tex; mode=display">f(X_t)=(0,x_1,...,x_n)</script><p>只是在路径的开头添加了一个0,这种转换使签名对路径的转换敏感，即消除了转换不变性，这对加密流量分类有利，因为不同的数据包大小代表不同的网站布局或服务内容</p><p>得到X<sub>t</sub><sup>0,d,c,b</sup>={f(U),f(D),f(U’),f(D’)}</p><blockquote><p>变换理由：原路径签名特征具有平移不变性，但加密流分类问题不需要这一属性，因此使用基点变换对流量路径进行变换。</p></blockquote><h3 id="1-4-4-结合时间变换"><a href="#1-4-4-结合时间变换" class="headerlink" title="1.4.4 结合时间变换"></a>1.4.4 结合时间变换</h3><ul><li>通过添加单调坐标(如时间)来丰富原有的线性路径，从而保证签名的唯一性。它通常对应于添加时间参数化作为路径坐标。</li><li>将交通路径5维路径X<sub>t</sub><sup>0,d,c,b,t</sup>={f(U),f(D),f(U’),f(D’),t<blockquote><p>变换理由：保证构建的流量路径具有唯一性</p></blockquote></li></ul><h2 id="1-5-路径特征抽取"><a href="#1-5-路径特征抽取" class="headerlink" title="1.5 路径特征抽取"></a>1.5 路径特征抽取</h2><ul><li><p>使用滑动窗口机制进行<strong>多尺度</strong>特征抽取</p><ul><li>提取分层特征，设置q层，有q个滑动窗口，对于第i层的滑动窗口W<sub>i</sub>,窗口长度与步长都是n2<sup>i-1</sup>，这将产生2<sup>q</sup>-1个子路径，自路径长度分别为n,n/2,n/4,…,n/2<sup>q-1</sup><ul><li>即对于第一层，窗口长度为n，步长为n，产生2^0=1个子路径</li><li>对于第二层，窗口与步长都是n/2, 产生2^1=1个子路径</li><li>对于第三层，窗口与步长都是n/4，产生2^2=4个子路径</li><li>……</li><li>对于第q层，产生2^q-1个子路径<br>故总的路径数目为<script type="math/tex; mode=display">2^0 +2^1 + ···+2^{q-1}=2^q-1</script>&emsp;&emsp;然后对于这2^q-1个子路径进行计算路径签名，作为分类器输入特征</li></ul></li><li><p>整体流程如下所示：</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129402.png" alt="image-20230119114153356"></p></li></ul></li><li><p>图中CS Sequence表示累积和系列</p></li></ul><hr><h1 id="2、实验"><a href="#2、实验" class="headerlink" title="2、实验"></a>2、实验</h1><h2 id="2-1-数据集"><a href="#2-1-数据集" class="headerlink" title="2.1 数据集"></a>2.1 数据集</h2><p> <img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129771.png" alt=""></p><h2 id="2-2-预处理"><a href="#2-2-预处理" class="headerlink" title="2.2 预处理"></a>2.2 预处理</h2><ul><li>分为session双向流，提取数据包长度</li><li>标记</li><li>过滤：对于流太短的，只有几个包，剔除；类别样本数目太少的，剔除</li></ul><h2 id="2-3-调参"><a href="#2-3-调参" class="headerlink" title="2.3 调参"></a>2.3 调参</h2><ul><li><p>序列长度：40</p></li><li><p>236个类别，每个类别45个样本</p></li></ul><h3 id="2-3-1-序列选择的调整"><a href="#2-3-1-序列选择的调整" class="headerlink" title="2.3.1 序列选择的调整"></a>2.3.1 序列选择的调整</h3><p>&emsp;&emsp;上文变换后的X<sub>t</sub><sup>0,d,c,b</sup>={f(U),f(D),f(U’),f(D’)}由四个一维序列组成，但是文中有六个序列，进行排列组合变换，找出最佳变换；</p><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129092.png" alt="image-20230119115903416"></p><p>最后选择选择U0序列、D0序列、U0 CS序列和D0 CS序列的组合路径，也就是段落1提到的路径组合。</p><h3 id="2-3-2-分类器选择"><a href="#2-3-2-分类器选择" class="headerlink" title="2.3.2 分类器选择"></a>2.3.2 分类器选择</h3><p>选RF随机森林</p><h3 id="2-3-3-参数选择"><a href="#2-3-3-参数选择" class="headerlink" title="2.3.3 参数选择"></a>2.3.3 参数选择</h3><p><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129145.png" alt="在这里插入图片描述"></p><p>签名深度为3<br>窗口深度q为4</p><blockquote><ul><li>关于序列长度增长，acc降低的分析：序列长度越长，路径包含的信息就越丰富，这就对模型提取特征的能力提出了更高的要求，而固定深度的路径签名和窗口窗口深度代表了固定的模型能力，随着序列长度增加，acc降低正常</li><li>路径签名的深度：在窗口深度为2的情况下，随着序列长度从40增加到200，精度之间的差距将逐渐明显，其中深度大的情况总是优于深度小的情况。因为路径签名深度大代表高阶psf，其中包含更多的路径细节。</li><li>窗口深度：当分层窗口深度从2增加到4时，准确率会逐渐提高。然而，大深度的分层窗口会导致PSF维度爆炸，并导致较高的计算成本。<br>……<h2 id="2-4-在开放世界数据的效果"><a href="#2-4-在开放世界数据的效果" class="headerlink" title="2.4 在开放世界数据的效果"></a>2.4 在开放世界数据的效果</h2><img src="https://raw.githubusercontent.com/lulu-cloud/lili_images/main/image/202311242129899.png" alt="在这里插入图片描述"></li></ul></blockquote><h1 id="3、总结与思考"><a href="#3、总结与思考" class="headerlink" title="3、总结与思考"></a>3、总结与思考</h1><p>缺陷：数据包填充技术会使得基于序列特征的方法失效。</p><p>&emsp;将深度学习应用于带路径签名的加密流分类是一个很有前景的研究方向，尤其是RNN。路径签名特征在移动加密流分类问题中的应用也很值得探索。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0、摘要&quot;&gt;&lt;a href=&quot;#0、摘要&quot; class=&quot;headerlink&quot; title=&quot;0、摘要&quot;&gt;&lt;/a&gt;0、摘要&lt;/h1&gt;&lt;p&gt;&amp;emsp;&amp;emsp;本文提出了一种新的带路径签名的加密流分类方法——ETC-PS。首先用&lt;strong&gt;会话数据包长度序
      
    
    </summary>
    
      <category term="科研" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/"/>
    
      <category term="加密流量分类" scheme="https://lulu-cloud.github.io/categories/%E7%A7%91%E7%A0%94/%E5%8A%A0%E5%AF%86%E6%B5%81%E9%87%8F%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="论文" scheme="https://lulu-cloud.github.io/tags/%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
</feed>
